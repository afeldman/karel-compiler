-- File generated by the BNF Converter (bnfc 2.9.6.1).

{-# LANGUAGE CPP #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE LambdaCase #-}

-- | Pretty-printer for PrintKarel.

module PrintKarel where

import Prelude
  ( ($), (.)
  , Bool(..), (==), (<)
  , Int, Integer, Double, (+), (-), (*)
  , String, (++)
  , ShowS, showChar, showString
  , all, elem, foldr, id, map, null, replicate, shows, span
  )
import Data.Char ( Char, isSpace )
import qualified AbsKarel

-- | The top-level printing method.

printTree :: Print a => a -> String
printTree = render . prt 0

type Doc = [ShowS] -> [ShowS]

doc :: ShowS -> Doc
doc = (:)

render :: Doc -> String
render d = rend 0 False (map ($ "") $ d []) ""
  where
  rend
    :: Int        -- ^ Indentation level.
    -> Bool       -- ^ Pending indentation to be output before next character?
    -> [String]
    -> ShowS
  rend i p = \case
      "["      :ts -> char '[' . rend i False ts
      "("      :ts -> char '(' . rend i False ts
      "{"      :ts -> onNewLine i     p . showChar   '{'  . new (i+1) ts
      "}" : ";":ts -> onNewLine (i-1) p . showString "};" . new (i-1) ts
      "}"      :ts -> onNewLine (i-1) p . showChar   '}'  . new (i-1) ts
      [";"]        -> char ';'
      ";"      :ts -> char ';' . new i ts
      t  : ts@(s:_) | closingOrPunctuation s
                   -> pending . showString t . rend i False ts
      t        :ts -> pending . space t      . rend i False ts
      []           -> id
    where
    -- Output character after pending indentation.
    char :: Char -> ShowS
    char c = pending . showChar c

    -- Output pending indentation.
    pending :: ShowS
    pending = if p then indent i else id

  -- Indentation (spaces) for given indentation level.
  indent :: Int -> ShowS
  indent i = replicateS (2*i) (showChar ' ')

  -- Continue rendering in new line with new indentation.
  new :: Int -> [String] -> ShowS
  new j ts = showChar '\n' . rend j True ts

  -- Make sure we are on a fresh line.
  onNewLine :: Int -> Bool -> ShowS
  onNewLine i p = (if p then id else showChar '\n') . indent i

  -- Separate given string from following text by a space (if needed).
  space :: String -> ShowS
  space t s =
    case (all isSpace t, null spc, null rest) of
      (True , _   , True ) -> []             -- remove trailing space
      (False, _   , True ) -> t              -- remove trailing space
      (False, True, False) -> t ++ ' ' : s   -- add space if none
      _                    -> t ++ s
    where
      (spc, rest) = span isSpace s

  closingOrPunctuation :: String -> Bool
  closingOrPunctuation [c] = c `elem` closerOrPunct
  closingOrPunctuation _   = False

  closerOrPunct :: String
  closerOrPunct = ")],;"

parenth :: Doc -> Doc
parenth ss = doc (showChar '(') . ss . doc (showChar ')')

concatS :: [ShowS] -> ShowS
concatS = foldr (.) id

concatD :: [Doc] -> Doc
concatD = foldr (.) id

replicateS :: Int -> ShowS -> ShowS
replicateS n f = concatS (replicate n f)

-- | The printer class does the job.

class Print a where
  prt :: Int -> a -> Doc

instance {-# OVERLAPPABLE #-} Print a => Print [a] where
  prt i = concatD . map (prt i)

instance Print Char where
  prt _ c = doc (showChar '\'' . mkEsc '\'' c . showChar '\'')

instance Print String where
  prt _ = printString

printString :: String -> Doc
printString s = doc (showChar '"' . concatS (map (mkEsc '"') s) . showChar '"')

mkEsc :: Char -> Char -> ShowS
mkEsc q = \case
  s | s == q -> showChar '\\' . showChar s
  '\\' -> showString "\\\\"
  '\n' -> showString "\\n"
  '\t' -> showString "\\t"
  s -> showChar s

prPrec :: Int -> Int -> Doc -> Doc
prPrec i j = if j < i then parenth else id

instance Print Integer where
  prt _ x = doc (shows x)

instance Print Double where
  prt _ x = doc (shows x)

instance Print AbsKarel.Ident where
  prt _ (AbsKarel.Ident i) = doc $ showString i
instance Print AbsKarel.QuotedString where
  prt _ (AbsKarel.QuotedString i) = doc $ showString i
instance Print AbsKarel.LineEnd where
  prt _ (AbsKarel.LineEnd i) = doc $ showString i
instance Print AbsKarel.Karel where
  prt i = \case
    AbsKarel.KarelGrammer id_1 optlineend directiveblocks declblocks stms id_2 routinedefinitionblocks -> prPrec i 0 (concatD [doc (showString "PROGRAM"), prt 0 id_1, prt 0 optlineend, prt 0 directiveblocks, prt 0 declblocks, doc (showString "BEGIN"), prt 0 stms, doc (showString "END"), prt 0 id_2, prt 0 routinedefinitionblocks])

instance Print AbsKarel.DirectiveBlock where
  prt i = \case
    AbsKarel.DirAlphabet -> prPrec i 0 (concatD [doc (showString "%ALPHABETIZE")])
    AbsKarel.DirCMOS -> prPrec i 0 (concatD [doc (showString "%CMOSVARS")])
    AbsKarel.DirCRT -> prPrec i 0 (concatD [doc (showString "%CRTDEVICE")])
    AbsKarel.DirNoBusy -> prPrec i 0 (concatD [doc (showString "%NOBUSYLAMP")])
    AbsKarel.DirNoLock -> prPrec i 0 (concatD [doc (showString "%NOLOCKGROUP")])
    AbsKarel.DirNoPauseS -> prPrec i 0 (concatD [doc (showString "%NOPAUSESHFT")])
    AbsKarel.DirRPMotion -> prPrec i 0 (concatD [doc (showString "%TPMOTION")])
    AbsKarel.DirComment text -> prPrec i 0 (concatD [doc (showString "%COMMENT"), doc (showString "="), prt 0 text])
    AbsKarel.DirDefGroup n -> prPrec i 0 (concatD [doc (showString "%DEFGROUP"), doc (showString "="), prt 0 n])
    AbsKarel.DirDelay n -> prPrec i 0 (concatD [doc (showString "%DELAY"), doc (showString "="), prt 0 n])
    AbsKarel.DirProp n -> prPrec i 0 (concatD [doc (showString "%PRIORITY"), doc (showString "="), prt 0 n])
    AbsKarel.DirStackSiz n -> prPrec i 0 (concatD [doc (showString "%STACKSIZE"), doc (showString "="), prt 0 n])
    AbsKarel.DirTimeSliz n -> prPrec i 0 (concatD [doc (showString "%TIMESLICE"), doc (showString "="), prt 0 n])
    AbsKarel.DirEnv id_ -> prPrec i 0 (concatD [doc (showString "%ENVIRONMENT"), doc (showString "="), prt 0 id_])
    AbsKarel.DirLock arrayindexings -> prPrec i 0 (concatD [doc (showString "%LOCKGROUP"), doc (showString "="), prt 0 arrayindexings])
    AbsKarel.DirNoAbort errorcommandblock -> prPrec i 0 (concatD [doc (showString "%NOABORT"), doc (showString "="), prt 0 errorcommandblock])
    AbsKarel.DirNoPause errorcommandtpblock -> prPrec i 0 (concatD [doc (showString "%NOPAUSE"), doc (showString "="), prt 0 errorcommandtpblock])
    AbsKarel.DirInclude text -> prPrec i 0 (concatD [doc (showString "%INCLUDE"), prt 0 text])
    AbsKarel.DirDefine id_ expression -> prPrec i 0 (concatD [doc (showString "%DEFINE"), prt 0 id_, prt 0 expression])
    AbsKarel.DirDefineConst id_ n -> prPrec i 0 (concatD [doc (showString "%DEFINE"), prt 0 id_, prt 0 n])
    AbsKarel.DirUndef id_ -> prPrec i 0 (concatD [doc (showString "%UNDEF"), prt 0 id_])
    AbsKarel.DirIfdef id_ -> prPrec i 0 (concatD [doc (showString "%IFDEF"), prt 0 id_])
    AbsKarel.DirIfndef id_ -> prPrec i 0 (concatD [doc (showString "%IFNDEF"), prt 0 id_])
    AbsKarel.DirIf expression -> prPrec i 0 (concatD [doc (showString "%IF"), prt 0 expression])
    AbsKarel.DirElse -> prPrec i 0 (concatD [doc (showString "%ELSE")])
    AbsKarel.DirEndif -> prPrec i 0 (concatD [doc (showString "%ENDIF")])

instance Print [AbsKarel.DirectiveBlock] where
  prt _ [] = concatD []
  prt _ (x:xs) = concatD [prt 0 x, prt 0 xs]

instance Print AbsKarel.ErrorCommandBlock where
  prt i = \case
    AbsKarel.ECBCom -> prPrec i 0 (concatD [doc (showString "COMMAND")])
    AbsKarel.ECBError -> prPrec i 0 (concatD [doc (showString "ERROR")])
    AbsKarel.ECBECom -> prPrec i 0 (concatD [doc (showString "ERROR"), doc (showString "+"), doc (showString "COMMAND")])

instance Print AbsKarel.ErrorCommandTPBlock where
  prt i = \case
    AbsKarel.ECTBECB errorcommandblock -> prPrec i 0 (concatD [prt 0 errorcommandblock])
    AbsKarel.ECTBCom -> prPrec i 0 (concatD [doc (showString "COMMAND"), doc (showString "+"), doc (showString "TPENABLE")])
    AbsKarel.ECTBErr -> prPrec i 0 (concatD [doc (showString "ERROR"), doc (showString "+"), doc (showString "TPENABLE")])
    AbsKarel.ECTBAnable -> prPrec i 0 (concatD [doc (showString "ERROR"), doc (showString "+"), doc (showString "COMMAND"), doc (showString "+"), doc (showString "TPENABLE")])

instance Print AbsKarel.DeclBlock where
  prt i = \case
    AbsKarel.DeclConst constdeclblock -> prPrec i 0 (concatD [prt 0 constdeclblock])
    AbsKarel.DeclType typedeclblock -> prPrec i 0 (concatD [prt 0 typedeclblock])
    AbsKarel.DeclVar vardeclblock -> prPrec i 0 (concatD [prt 0 vardeclblock])
    AbsKarel.DeclRoutine routinedeclblock -> prPrec i 0 (concatD [prt 0 routinedeclblock])

instance Print [AbsKarel.DeclBlock] where
  prt _ [] = concatD []
  prt _ (x:xs) = concatD [prt 0 x, prt 0 xs]

instance Print AbsKarel.ConstDeclBlock where
  prt i = \case
    AbsKarel.CDB optlineend constdecls -> prPrec i 0 (concatD [doc (showString "CONST"), prt 0 optlineend, prt 0 constdecls])

instance Print AbsKarel.ConstDecl where
  prt i = \case
    AbsKarel.CDIdent id_1 id_2 optlineend -> prPrec i 0 (concatD [prt 0 id_1, doc (showString "="), prt 0 id_2, prt 0 optlineend])
    AbsKarel.CDLiteral id_ literal optlineend -> prPrec i 0 (concatD [prt 0 id_, doc (showString "="), prt 0 literal, prt 0 optlineend])

instance Print [AbsKarel.ConstDecl] where
  prt _ [] = concatD []
  prt _ (x:xs) = concatD [prt 0 x, prt 0 xs]

instance Print AbsKarel.TypeDeclBlock where
  prt i = \case
    AbsKarel.TCB optlineend typedecls -> prPrec i 0 (concatD [doc (showString "TYPE"), prt 0 optlineend, prt 0 typedecls])

instance Print AbsKarel.TypeDecl where
  prt i = \case
    AbsKarel.TDeclU id_1 id_2 usertype optlineend -> prPrec i 0 (concatD [prt 0 id_1, doc (showString "FROM"), prt 0 id_2, prt 0 usertype, prt 0 optlineend])
    AbsKarel.TUser id_ usertype optlineend -> prPrec i 0 (concatD [prt 0 id_, doc (showString "="), prt 0 usertype, prt 0 optlineend])
    AbsKarel.TUserD usertype optlineend -> prPrec i 0 (concatD [prt 0 usertype, prt 0 optlineend])

instance Print [AbsKarel.TypeDecl] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 0 x]
  prt _ (x:xs) = concatD [prt 0 x, prt 0 xs]

instance Print AbsKarel.VarDeclBlock where
  prt i = \case
    AbsKarel.VDB optlineend vardecls -> prPrec i 0 (concatD [doc (showString "VAR"), prt 0 optlineend, prt 0 vardecls])

instance Print AbsKarel.VarDecl where
  prt i = \case
    AbsKarel.VarDIden id_ optlineend vardecl -> prPrec i 0 (concatD [prt 0 id_, doc (showString ","), prt 0 optlineend, prt 0 vardecl])
    AbsKarel.VarDDtype id_ memtypes fromblock datatypes -> prPrec i 0 (concatD [prt 0 id_, prt 0 memtypes, prt 0 fromblock, doc (showString ":"), prt 0 datatypes])

instance Print [AbsKarel.VarDecl] where
  prt _ [] = concatD []
  prt _ (x:xs) = concatD [prt 0 x, prt 0 xs]

instance Print AbsKarel.RoutineDeclBlock where
  prt i = \case
    AbsKarel.RoutineDeclarationBlock id_ routineparameter fromblock -> prPrec i 0 (concatD [doc (showString "ROUTINE"), prt 0 id_, prt 0 routineparameter, prt 0 fromblock])

instance Print AbsKarel.RoutineParameter where
  prt i = \case
    AbsKarel.RoutineParamBrack parameterfields -> prPrec i 0 (concatD [doc (showString "("), prt 0 parameterfields, doc (showString ")")])
    AbsKarel.RoutineReturn parameterfields returndatatypes -> prPrec i 0 (concatD [doc (showString "("), prt 0 parameterfields, doc (showString ")"), doc (showString ":"), prt 0 returndatatypes])

instance Print AbsKarel.ParameterField where
  prt i = \case
    AbsKarel.ParamFieldIdent paramident parameterdatatypes -> prPrec i 0 (concatD [prt 0 paramident, doc (showString ":"), prt 0 parameterdatatypes])
    AbsKarel.ParamFieldDecl paramident paramidents parameterdatatypes -> prPrec i 0 (concatD [prt 0 paramident, doc (showString ","), prt 0 paramidents, doc (showString ":"), prt 0 parameterdatatypes])
    AbsKarel.ParamDefaultDecl paramident paramidents parameterdatatypes expression -> prPrec i 0 (concatD [prt 0 paramident, doc (showString ","), prt 0 paramidents, doc (showString ":"), prt 0 parameterdatatypes, doc (showString "="), prt 0 expression])

instance Print [AbsKarel.ParameterField] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 0 x]
  prt _ (x:xs) = concatD [prt 0 x, doc (showString ";"), prt 0 xs]

instance Print AbsKarel.ParamIdent where
  prt i = \case
    AbsKarel.ParamType id_ -> prPrec i 0 (concatD [prt 0 id_])

instance Print [AbsKarel.ParamIdent] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 0 x]
  prt _ (x:xs) = concatD [prt 0 x, doc (showString ","), prt 0 xs]

instance Print AbsKarel.RoutineDefinitionBlock where
  prt i = \case
    AbsKarel.RoutineDefineBlock id_1 optlineend declblocks stms id_2 -> prPrec i 0 (concatD [doc (showString "ROUTINE"), prt 0 id_1, prt 0 optlineend, prt 0 declblocks, doc (showString "BEGIN"), prt 0 stms, doc (showString "END"), prt 0 id_2])

instance Print [AbsKarel.RoutineDefinitionBlock] where
  prt _ [] = concatD []
  prt _ (x:xs) = concatD [prt 0 x, prt 0 xs]

instance Print AbsKarel.FromBlock where
  prt i = \case
    AbsKarel.FromBIdent id_ -> prPrec i 0 (concatD [doc (showString "FROM"), prt 0 id_])
    AbsKarel.FromBEmpty empty -> prPrec i 0 (concatD [prt 0 empty])

instance Print AbsKarel.GlobalCondition where
  prt i = \case
    AbsKarel.GCBase globalcondition -> prPrec i 0 (concatD [doc (showString "("), prt 0 globalcondition, doc (showString ")")])
    AbsKarel.GCError arrayindexings -> prPrec i 0 (concatD [doc (showString "ERROR"), doc (showString "["), prt 0 arrayindexings, doc (showString "]")])
    AbsKarel.GCEvent arrayindexings -> prPrec i 0 (concatD [doc (showString "EVENT"), doc (showString "["), prt 0 arrayindexings, doc (showString "]")])
    AbsKarel.GCSemaphore arrayindexings -> prPrec i 0 (concatD [doc (showString "SEMAPHORE"), doc (showString "["), prt 0 arrayindexings, doc (showString "]")])
    AbsKarel.GCPowerUp -> prPrec i 0 (concatD [doc (showString "POWERUP")])
    AbsKarel.GCAbort globalconditionselect -> prPrec i 0 (concatD [doc (showString "ABORT"), prt 0 globalconditionselect])
    AbsKarel.GCPause globalconditionselect -> prPrec i 0 (concatD [doc (showString "PAUSE"), prt 0 globalconditionselect])
    AbsKarel.GCCONTINUE globalconditionselect -> prPrec i 0 (concatD [doc (showString "CONTINUE"), prt 0 globalconditionselect])
    AbsKarel.GCVarAccess globalconditionbool -> prPrec i 0 (concatD [prt 0 globalconditionbool])
    AbsKarel.GCPortCond id_ expression sign -> prPrec i 0 (concatD [prt 0 id_, doc (showString "["), prt 0 expression, doc (showString "]"), prt 0 sign])
    AbsKarel.GCNotPortCond id_ expression sign -> prPrec i 0 (concatD [doc (showString "NOT"), prt 0 id_, doc (showString "["), prt 0 expression, doc (showString "]"), prt 0 sign])

instance Print AbsKarel.GlobalConditionSelect where
  prt i = \case
    AbsKarel.GCSProg expression -> prPrec i 0 (concatD [doc (showString "PROGRAM"), doc (showString "["), prt 0 expression, doc (showString "]")])
    AbsKarel.GCSEmpty empty -> prPrec i 0 (concatD [prt 0 empty])

instance Print AbsKarel.GlobalConditionBool where
  prt i = \case
    AbsKarel.GCBEqual id_ globalconditionvarselect -> prPrec i 0 (concatD [prt 0 id_, doc (showString "="), prt 0 globalconditionvarselect])
    AbsKarel.GCBNEqual id_ globalconditionvarselect -> prPrec i 0 (concatD [prt 0 id_, doc (showString "<>"), prt 0 globalconditionvarselect])
    AbsKarel.GCBLess id_ globalconditionvarselect -> prPrec i 0 (concatD [prt 0 id_, doc (showString "<"), prt 0 globalconditionvarselect])
    AbsKarel.GCBLessEQ id_ globalconditionvarselect -> prPrec i 0 (concatD [prt 0 id_, doc (showString "<="), prt 0 globalconditionvarselect])
    AbsKarel.GCBGread id_ globalconditionvarselect -> prPrec i 0 (concatD [prt 0 id_, doc (showString ">"), prt 0 globalconditionvarselect])
    AbsKarel.GCBGEQ id_ globalconditionvarselect -> prPrec i 0 (concatD [prt 0 id_, doc (showString ">="), prt 0 globalconditionvarselect])

instance Print AbsKarel.GlobalConditionVarSelect where
  prt i = \case
    AbsKarel.GCVSBase constant -> prPrec i 0 (concatD [prt 0 constant])
    AbsKarel.GCVSEval expression -> prPrec i 0 (concatD [doc (showString "EVAL"), doc (showString "("), prt 0 expression, doc (showString ")")])

instance Print AbsKarel.ConditionHandlerAction where
  prt i = \case
    AbsKarel.CHAEmpty empty -> prPrec i 0 (concatD [prt 0 empty])
    AbsKarel.CHANoAbort -> prPrec i 0 (concatD [doc (showString "NOABORT")])
    AbsKarel.CHANoPause -> prPrec i 0 (concatD [doc (showString "NOPAUSE")])
    AbsKarel.CHAUnPause -> prPrec i 0 (concatD [doc (showString "UNPAUSE")])
    AbsKarel.CHANoMessage -> prPrec i 0 (concatD [doc (showString "NOMESSAGE")])
    AbsKarel.CHARestore -> prPrec i 0 (concatD [doc (showString "RESTORE")])
    AbsKarel.CHAHold groups -> prPrec i 0 (concatD [doc (showString "HOLD"), prt 0 groups])
    AbsKarel.CHAUnHold groups -> prPrec i 0 (concatD [doc (showString "UNHOLD"), prt 0 groups])
    AbsKarel.CHAResum groups -> prPrec i 0 (concatD [doc (showString "RESUME"), prt 0 groups])
    AbsKarel.CHAStop groups -> prPrec i 0 (concatD [doc (showString "STOP"), prt 0 groups])
    AbsKarel.CHACancel groups -> prPrec i 0 (concatD [doc (showString "CANCEL"), prt 0 groups])
    AbsKarel.CHAEnable expression -> prPrec i 0 (concatD [doc (showString "ENABLE"), doc (showString "CONDITION"), doc (showString "["), prt 0 expression, doc (showString "]")])
    AbsKarel.CHADisable expression -> prPrec i 0 (concatD [doc (showString "DISABLE"), doc (showString "CONDITION"), doc (showString "["), prt 0 expression, doc (showString "]")])
    AbsKarel.CHASignalEvent expression -> prPrec i 0 (concatD [doc (showString "SIGNAL"), doc (showString "EVENT"), doc (showString "["), prt 0 expression, doc (showString "]")])
    AbsKarel.CHASignalSema expression -> prPrec i 0 (concatD [doc (showString "SIGNAL"), doc (showString "SEMAPHORE"), doc (showString "["), prt 0 expression, doc (showString "]")])
    AbsKarel.CHAIdent id_ -> prPrec i 0 (concatD [prt 0 id_])
    AbsKarel.CHAPulse pulseout expression n -> prPrec i 0 (concatD [doc (showString "PULSE"), prt 0 pulseout, doc (showString "["), prt 0 expression, doc (showString "]"), doc (showString "FOR"), prt 0 n])
    AbsKarel.CHAAbort -> prPrec i 0 (concatD [doc (showString "ABORT")])
    AbsKarel.CHAAbortProg expression -> prPrec i 0 (concatD [doc (showString "ABORT"), doc (showString "PROGRAM"), doc (showString "["), prt 0 expression, doc (showString "]")])
    AbsKarel.CHAContinue -> prPrec i 0 (concatD [doc (showString "CONTINUE")])
    AbsKarel.CHAContProg expression -> prPrec i 0 (concatD [doc (showString "CONTINUE"), doc (showString "PROGRAM"), doc (showString "["), prt 0 expression, doc (showString "]")])
    AbsKarel.CHAPause -> prPrec i 0 (concatD [doc (showString "PAUSE")])
    AbsKarel.CHAPauseProg expression -> prPrec i 0 (concatD [doc (showString "PAUSE"), doc (showString "PROGRAM"), doc (showString "["), prt 0 expression, doc (showString "]")])
    AbsKarel.CHAVarAccess varaccess id_ expression -> prPrec i 0 (concatD [prt 0 varaccess, doc (showString "="), prt 0 id_, doc (showString "["), prt 0 expression, doc (showString "]")])
    AbsKarel.CHAVarAccEval varaccess expression -> prPrec i 0 (concatD [prt 0 varaccess, doc (showString "="), doc (showString "EVAL"), doc (showString "("), prt 0 expression, doc (showString ")")])
    AbsKarel.CHAVarAccConst varaccess constant -> prPrec i 0 (concatD [prt 0 varaccess, doc (showString "="), prt 0 constant])
    AbsKarel.CHAPortVA n expression varaccess -> prPrec i 0 (concatD [prt 0 n, doc (showString "["), prt 0 expression, doc (showString "]"), doc (showString "="), prt 0 varaccess])
    AbsKarel.CHAPortEval n expression1 expression2 -> prPrec i 0 (concatD [prt 0 n, doc (showString "["), prt 0 expression1, doc (showString "]"), doc (showString "="), doc (showString "EVAL"), doc (showString "("), prt 0 expression2, doc (showString ")")])

instance Print [AbsKarel.ConditionHandlerAction] where
  prt _ [] = concatD []
  prt _ (x:xs) = concatD [prt 0 x, doc (showString ","), prt 0 xs]

instance Print AbsKarel.Stm where
  prt i = \case
    AbsKarel.SAttach -> prPrec i 0 (concatD [doc (showString "ATTACH")])
    AbsKarel.SRelease -> prPrec i 0 (concatD [doc (showString "RELEASE")])
    AbsKarel.SAbort -> prPrec i 0 (concatD [doc (showString "ABORT")])
    AbsKarel.SAbortP arrayindexings -> prPrec i 0 (concatD [doc (showString "ABORT"), doc (showString "PROGRAM"), doc (showString "["), prt 0 arrayindexings, doc (showString "]")])
    AbsKarel.SAssign id_ expression -> prPrec i 0 (concatD [prt 0 id_, doc (showString "="), prt 0 expression])
    AbsKarel.SCloseFile id_ -> prPrec i 0 (concatD [doc (showString "CLOSE"), doc (showString "FILE"), prt 0 id_])
    AbsKarel.SCloseHand n -> prPrec i 0 (concatD [doc (showString "CLOSE"), doc (showString "HAND"), prt 0 n])
    AbsKarel.SDelay n -> prPrec i 0 (concatD [doc (showString "DELAY"), prt 0 n])
    AbsKarel.SConnect n -> prPrec i 0 (concatD [doc (showString "CONNECT"), doc (showString "TIMER"), doc (showString "TO"), prt 0 n])
    AbsKarel.SDisable arrayindexings -> prPrec i 0 (concatD [doc (showString "DISABLE"), doc (showString "CONDITION"), doc (showString "["), prt 0 arrayindexings, doc (showString "]")])
    AbsKarel.SDisconectT n -> prPrec i 0 (concatD [doc (showString "DISCONNECT"), doc (showString "TIMER"), prt 0 n])
    AbsKarel.SEnable arrayindexings -> prPrec i 0 (concatD [doc (showString "ENABLE"), doc (showString "CONDITION"), doc (showString "["), prt 0 arrayindexings, doc (showString "]")])
    AbsKarel.SOpenHand n -> prPrec i 0 (concatD [doc (showString "OPEN"), doc (showString "HAND"), prt 0 n])
    AbsKarel.SPurge arrayindexings -> prPrec i 0 (concatD [doc (showString "PURGE"), doc (showString "CONDITION"), doc (showString "["), prt 0 arrayindexings, doc (showString "]")])
    AbsKarel.SRelax n -> prPrec i 0 (concatD [doc (showString "RELAX"), doc (showString "HAND"), prt 0 n])
    AbsKarel.SSignal arrayindexings -> prPrec i 0 (concatD [doc (showString "SIGNAL"), doc (showString "EVENT"), doc (showString "["), prt 0 arrayindexings, doc (showString "]")])
    AbsKarel.SCancel -> prPrec i 0 (concatD [doc (showString "CANCEL")])
    AbsKarel.SCancelFile id_ -> prPrec i 0 (concatD [doc (showString "CANCEL"), doc (showString "FILE"), prt 0 id_])
    AbsKarel.SCancelGroup groups -> prPrec i 0 (concatD [doc (showString "CANCEL"), prt 0 groups])
    AbsKarel.SCallparamExp id_ expressions -> prPrec i 0 (concatD [prt 0 id_, doc (showString "("), prt 0 expressions, doc (showString ")")])
    AbsKarel.SForTo id_ n1 n2 stms -> prPrec i 0 (concatD [doc (showString "FOR"), prt 0 id_, doc (showString "="), prt 0 n1, doc (showString "TO"), prt 0 n2, doc (showString "DO"), prt 0 stms, doc (showString "ENDFOR")])
    AbsKarel.SForDownTo id_ n1 n2 stms -> prPrec i 0 (concatD [doc (showString "FOR"), prt 0 id_, doc (showString "="), prt 0 n1, doc (showString "DOWNTO"), prt 0 n2, doc (showString "DO"), prt 0 stms, doc (showString "ENDFOR")])
    AbsKarel.SGoTo id_ -> prPrec i 0 (concatD [doc (showString "GOTO"), prt 0 id_])
    AbsKarel.SGo_To id_ -> prPrec i 0 (concatD [doc (showString "GO"), doc (showString "TO"), prt 0 id_])
    AbsKarel.SHold -> prPrec i 0 (concatD [doc (showString "HOLD")])
    AbsKarel.SHoleGroup groups -> prPrec i 0 (concatD [doc (showString "HOLD"), prt 0 groups])
    AbsKarel.SIfThen expression stms -> prPrec i 0 (concatD [doc (showString "IF"), prt 0 expression, doc (showString "THEN"), prt 0 stms, doc (showString "ENDIF")])
    AbsKarel.SIfThenElse expression stms1 stms2 -> prPrec i 0 (concatD [doc (showString "IF"), prt 0 expression, doc (showString "THEN"), prt 0 stms1, doc (showString "ELSE"), prt 0 stms2, doc (showString "EDNIF")])
    AbsKarel.SPause -> prPrec i 0 (concatD [doc (showString "PAUSE")])
    AbsKarel.SPauseProgram arrayindexings -> prPrec i 0 (concatD [doc (showString "PAUSE"), doc (showString "PROGRAM"), doc (showString "["), prt 0 arrayindexings, doc (showString "]")])
    AbsKarel.SPulse pulseout arrayindexings expression nwait -> prPrec i 0 (concatD [doc (showString "PULSE"), prt 0 pulseout, doc (showString "["), prt 0 arrayindexings, doc (showString "]"), doc (showString "FOR"), prt 0 expression, prt 0 nwait])
    AbsKarel.SOpenFile id_ expression1 expression2 -> prPrec i 0 (concatD [doc (showString "OPEN"), doc (showString "FILE"), prt 0 id_, doc (showString "("), prt 0 expression1, doc (showString ","), prt 0 expression2, doc (showString ")")])
    AbsKarel.SReadIdent id_ readitems -> prPrec i 0 (concatD [doc (showString "READ"), prt 0 id_, doc (showString "("), prt 0 readitems, doc (showString ")")])
    AbsKarel.SRead readitems -> prPrec i 0 (concatD [doc (showString "READ"), doc (showString "("), prt 0 readitems, doc (showString ")")])
    AbsKarel.SReturn -> prPrec i 0 (concatD [doc (showString "RETURN")])
    AbsKarel.SReturnExp expression -> prPrec i 0 (concatD [doc (showString "RETURN"), doc (showString "("), prt 0 expression, doc (showString ")")])
    AbsKarel.SUsing varaccesss stms -> prPrec i 0 (concatD [doc (showString "USING"), prt 0 varaccesss, doc (showString "DO"), prt 0 stms, doc (showString "ENDUSING")])
    AbsKarel.SUnHold -> prPrec i 0 (concatD [doc (showString "UNHOLD")])
    AbsKarel.SUnHoldExt groups -> prPrec i 0 (concatD [doc (showString "UNHOLD"), prt 0 groups])
    AbsKarel.SStop -> prPrec i 0 (concatD [doc (showString "STOP")])
    AbsKarel.SStopExt groups -> prPrec i 0 (concatD [doc (showString "STOP"), prt 0 groups])
    AbsKarel.SSelect expression casestms -> prPrec i 0 (concatD [doc (showString "SELECT"), prt 0 expression, doc (showString "OF"), prt 0 casestms, doc (showString "ENDSELECT")])
    AbsKarel.SSelectElse expression casestms stms -> prPrec i 0 (concatD [doc (showString "SELECT"), prt 0 expression, doc (showString "OF"), prt 0 casestms, doc (showString "ELSE"), prt 0 stms, doc (showString "ENDSELECT")])
    AbsKarel.SRepeat stms expression -> prPrec i 0 (concatD [doc (showString "REPEAT"), prt 0 stms, doc (showString "UNTIL"), prt 0 expression])
    AbsKarel.SResum -> prPrec i 0 (concatD [doc (showString "RESUM")])
    AbsKarel.SResumGroup groups -> prPrec i 0 (concatD [doc (showString "RESUM"), prt 0 groups])
    AbsKarel.SWait waitselect -> prPrec i 0 (concatD [doc (showString "WAIT"), doc (showString "FOR"), prt 0 waitselect])
    AbsKarel.SWhile expression stms -> prPrec i 0 (concatD [doc (showString "WHILE"), prt 0 expression, doc (showString "DO"), prt 0 stms, doc (showString "ENDWHILE")])
    AbsKarel.SWrite id_ writeitems -> prPrec i 0 (concatD [doc (showString "WRITE"), prt 0 id_, doc (showString "("), prt 0 writeitems, doc (showString ")")])
    AbsKarel.SCondition arrayindexings conditionwhenstm -> prPrec i 0 (concatD [doc (showString "CONDITION"), doc (showString "["), prt 0 arrayindexings, doc (showString "]"), doc (showString ":"), prt 0 conditionwhenstm, doc (showString "ENDCONDITION")])
    AbsKarel.SConditionWith arrayindexings conditionwithstms conditionwhenstm -> prPrec i 0 (concatD [doc (showString "CONDITION"), doc (showString "["), prt 0 arrayindexings, doc (showString "]"), doc (showString ":"), doc (showString "WITH"), prt 0 conditionwithstms, prt 0 conditionwhenstm, doc (showString "ENDCONDITION")])
    AbsKarel.SMove expression -> prPrec i 0 (concatD [doc (showString "MOVE"), doc (showString "TO"), prt 0 expression])
    AbsKarel.SMoveLinear expression -> prPrec i 0 (concatD [doc (showString "MOVE"), doc (showString "LINEAR"), doc (showString "TO"), prt 0 expression])
    AbsKarel.SMoveJoint expression -> prPrec i 0 (concatD [doc (showString "MOVE"), doc (showString "JOINT"), doc (showString "TO"), prt 0 expression])
    AbsKarel.SMoveCircular expression1 expression2 -> prPrec i 0 (concatD [doc (showString "MOVE"), doc (showString "CIRCULAR"), doc (showString "TO"), prt 0 expression1, doc (showString "VIA"), prt 0 expression2])
    AbsKarel.SGetVar expression1 id_1 expression2 id_2 -> prPrec i 0 (concatD [doc (showString "GET_VAR"), doc (showString "("), prt 0 expression1, doc (showString ","), prt 0 id_1, doc (showString ","), prt 0 expression2, doc (showString ","), prt 0 id_2, doc (showString ")")])
    AbsKarel.SSetVar expression1 id_1 expression2 expression3 id_2 -> prPrec i 0 (concatD [doc (showString "SET_VAR"), doc (showString "("), prt 0 expression1, doc (showString ","), prt 0 id_1, doc (showString ","), prt 0 expression2, doc (showString ","), prt 0 expression3, doc (showString ","), prt 0 id_2, doc (showString ")")])
    AbsKarel.SGetPort expression id_ -> prPrec i 0 (concatD [doc (showString "GET_PORT"), doc (showString "("), prt 0 expression, doc (showString ","), prt 0 id_, doc (showString ")")])
    AbsKarel.SSetPort expression1 expression2 id_ -> prPrec i 0 (concatD [doc (showString "SET_PORT"), doc (showString "("), prt 0 expression1, doc (showString ","), prt 0 expression2, doc (showString ","), prt 0 id_, doc (showString ")")])
    AbsKarel.SGetReg expression id_1 id_2 -> prPrec i 0 (concatD [doc (showString "GET_REG"), doc (showString "("), prt 0 expression, doc (showString ","), prt 0 id_1, doc (showString ","), prt 0 id_2, doc (showString ")")])
    AbsKarel.SSetReg expression1 expression2 id_ -> prPrec i 0 (concatD [doc (showString "SET_REG"), doc (showString "("), prt 0 expression1, doc (showString ","), prt 0 expression2, doc (showString ","), prt 0 id_, doc (showString ")")])
    AbsKarel.SGetTPE id_1 id_2 id_3 -> prPrec i 0 (concatD [doc (showString "GET_TPE_PRM"), doc (showString "("), prt 0 id_1, doc (showString ","), prt 0 id_2, doc (showString ","), prt 0 id_3, doc (showString ")")])
    AbsKarel.SSetTPE id_1 id_2 id_3 -> prPrec i 0 (concatD [doc (showString "SET_TPE_PRM"), doc (showString "("), prt 0 id_1, doc (showString ","), prt 0 id_2, doc (showString ","), prt 0 id_3, doc (showString ")")])
    AbsKarel.SClearTPE -> prPrec i 0 (concatD [doc (showString "CLR_TPE_STAT")])
    AbsKarel.SGetJPos expression id_1 id_2 -> prPrec i 0 (concatD [doc (showString "GET_JPOS_REG"), doc (showString "("), prt 0 expression, doc (showString ","), prt 0 id_1, doc (showString ","), prt 0 id_2, doc (showString ")")])
    AbsKarel.SSetJPos expression id_1 id_2 -> prPrec i 0 (concatD [doc (showString "SET_JPOS_REG"), doc (showString "("), prt 0 expression, doc (showString ","), prt 0 id_1, doc (showString ","), prt 0 id_2, doc (showString ")")])
    AbsKarel.SGetPosReg expression id_1 id_2 -> prPrec i 0 (concatD [doc (showString "GET_POS_REG"), doc (showString "("), prt 0 expression, doc (showString ","), prt 0 id_1, doc (showString ","), prt 0 id_2, doc (showString ")")])
    AbsKarel.SSetPosReg expression id_1 id_2 -> prPrec i 0 (concatD [doc (showString "SET_POS_REG"), doc (showString "("), prt 0 expression, doc (showString ","), prt 0 id_1, doc (showString ","), prt 0 id_2, doc (showString ")")])
    AbsKarel.SGetPosTPE id_1 id_2 id_3 -> prPrec i 0 (concatD [doc (showString "GET_POS_TPE"), doc (showString "("), prt 0 id_1, doc (showString ","), prt 0 id_2, doc (showString ","), prt 0 id_3, doc (showString ")")])
    AbsKarel.SSetPosTPE id_1 id_2 id_3 -> prPrec i 0 (concatD [doc (showString "SET_POS_TPE"), doc (showString "("), prt 0 id_1, doc (showString ","), prt 0 id_2, doc (showString ","), prt 0 id_3, doc (showString ")")])
    AbsKarel.SMsg expression id_ -> prPrec i 0 (concatD [doc (showString "MSG_OK"), doc (showString "("), prt 0 expression, doc (showString ","), prt 0 id_, doc (showString ")")])
    AbsKarel.SActScreen id_ -> prPrec i 0 (concatD [doc (showString "ACTIVATE_SCREEN"), doc (showString "("), prt 0 id_, doc (showString ")")])
    AbsKarel.SDeactScreen id_ -> prPrec i 0 (concatD [doc (showString "DEACTIVATE_SCREEN"), doc (showString "("), prt 0 id_, doc (showString ")")])

instance Print AbsKarel.ConditionWhenStm where
  prt i = \case
    AbsKarel.CWSTMWhen globalconditionlist conditionhandleractions -> prPrec i 0 (concatD [doc (showString "WHEN"), prt 0 globalconditionlist, doc (showString "DO"), prt 0 conditionhandleractions])

instance Print AbsKarel.ConditionWithStm where
  prt i = \case
    AbsKarel.CWSTMWith id_1 arrayindexings id_2 expression -> prPrec i 0 (concatD [prt 0 id_1, doc (showString "["), prt 0 arrayindexings, doc (showString "]"), prt 0 id_2, doc (showString "="), prt 0 expression])

instance Print [AbsKarel.ConditionWithStm] where
  prt _ [] = concatD []
  prt _ (x:xs) = concatD [prt 0 x, doc (showString ","), prt 0 xs]

instance Print AbsKarel.GlobalConditionList where
  prt i = \case
    AbsKarel.GCLAnd globalcondition1 globalcondition2 -> prPrec i 0 (concatD [prt 0 globalcondition1, doc (showString "AND"), prt 0 globalcondition2])
    AbsKarel.GCLOr globalcondition1 globalcondition2 -> prPrec i 0 (concatD [prt 0 globalcondition1, doc (showString "OR"), prt 0 globalcondition2])

instance Print AbsKarel.Groups where
  prt i = \case
    AbsKarel.GroupBase arrayindexings -> prPrec i 0 (concatD [doc (showString "GROUP"), doc (showString "["), prt 0 arrayindexings, doc (showString "]")])

instance Print [AbsKarel.Stm] where
  prt _ [] = concatD []
  prt _ (x:xs) = concatD [prt 0 x, prt 0 xs]

instance Print AbsKarel.WaitSelect where
  prt i = \case
    AbsKarel.WaitSelectGC globalcondition -> prPrec i 0 (concatD [prt 0 globalcondition])
    AbsKarel.WaitSelectAND globalcondition1 globalcondition2 -> prPrec i 0 (concatD [prt 0 globalcondition1, doc (showString "AND"), prt 0 globalcondition2])
    AbsKarel.WaitSelectOR globalcondition1 globalcondition2 -> prPrec i 0 (concatD [prt 0 globalcondition1, doc (showString "OR"), prt 0 globalcondition2])

instance Print AbsKarel.CaseStm where
  prt i = \case
    AbsKarel.SCase arrayindexings stms -> prPrec i 0 (concatD [doc (showString "CASE"), doc (showString "("), prt 0 arrayindexings, doc (showString ")"), doc (showString ":"), prt 0 stms])

instance Print [AbsKarel.CaseStm] where
  prt _ [] = concatD []
  prt _ (x:xs) = concatD [prt 0 x, doc (showString ";"), prt 0 xs]

instance Print AbsKarel.VarAccess where
  prt i = \case
    AbsKarel.SVarAccess id_ -> prPrec i 0 (concatD [prt 0 id_])
    AbsKarel.SVarAccessIdent varaccess id_ -> prPrec i 0 (concatD [prt 0 varaccess, doc (showString "."), prt 0 id_])
    AbsKarel.SVarAccessArray varaccess arrayindexings -> prPrec i 0 (concatD [prt 0 varaccess, doc (showString "["), prt 0 arrayindexings, doc (showString "]")])
    AbsKarel.SVarAccessPath varaccess expression1 expression2 -> prPrec i 0 (concatD [prt 0 varaccess, doc (showString "["), prt 0 expression1, doc (showString ".."), prt 0 expression2, doc (showString "]")])

instance Print [AbsKarel.VarAccess] where
  prt _ [] = concatD []
  prt _ (x:xs) = concatD [prt 0 x, doc (showString ","), prt 0 xs]

instance Print AbsKarel.ReadItem where
  prt i = \case
    AbsKarel.SReadItem cr formatspec -> prPrec i 0 (concatD [prt 0 cr, prt 0 formatspec])

instance Print [AbsKarel.ReadItem] where
  prt _ [] = concatD []
  prt _ (x:xs) = concatD [prt 0 x, doc (showString ","), prt 0 xs]

instance Print AbsKarel.WriteItem where
  prt i = \case
    AbsKarel.SWriteItem cr formatspec -> prPrec i 0 (concatD [prt 0 cr, prt 0 formatspec])
    AbsKarel.SWriteItemExp expression formatspec -> prPrec i 0 (concatD [prt 0 expression, prt 0 formatspec])

instance Print [AbsKarel.WriteItem] where
  prt _ [] = concatD []
  prt _ (x:xs) = concatD [prt 0 x, doc (showString ","), prt 0 xs]

instance Print AbsKarel.FormatSpec where
  prt i = \case
    AbsKarel.FormatSpec1 expression -> prPrec i 0 (concatD [doc (showString "::"), prt 0 expression])
    AbsKarel.FormatSpec2 expression1 expression2 -> prPrec i 0 (concatD [doc (showString "::"), prt 0 expression1, doc (showString "::"), prt 0 expression2])
    AbsKarel.FormatSpecEmpty empty -> prPrec i 0 (concatD [prt 0 empty])

instance Print AbsKarel.CR where
  prt i = \case
    AbsKarel.RIDefault -> prPrec i 0 (concatD [doc (showString "CR")])
    AbsKarel.RICar id_ -> prPrec i 0 (concatD [prt 0 id_])

instance Print AbsKarel.PulseOut where
  prt i = \case
    AbsKarel.SSPulseOut -> prPrec i 0 (concatD [doc (showString "DOUT")])
    AbsKarel.SSPulseRDO -> prPrec i 0 (concatD [doc (showString "RDO")])

instance Print AbsKarel.Nwait where
  prt i = \case
    AbsKarel.SSWait -> prPrec i 0 (concatD [doc (showString "NOWAIT")])
    AbsKarel.SSWaitEmapty empty -> prPrec i 0 (concatD [prt 0 empty])

instance Print AbsKarel.Expression where
  prt i = \case
    AbsKarel.EBrack expression -> prPrec i 0 (concatD [doc (showString "("), prt 0 expression, doc (showString ")")])
    AbsKarel.EEqual expression1 expression2 -> prPrec i 0 (concatD [prt 0 expression1, doc (showString "="), prt 0 expression2])
    AbsKarel.ENEqual expression1 expression2 -> prPrec i 0 (concatD [prt 0 expression1, doc (showString "<>"), prt 0 expression2])
    AbsKarel.ELess expression1 expression2 -> prPrec i 0 (concatD [prt 0 expression1, doc (showString "<"), prt 0 expression2])
    AbsKarel.ELeq expression1 expression2 -> prPrec i 0 (concatD [prt 0 expression1, doc (showString "<="), prt 0 expression2])
    AbsKarel.Egret expression1 expression2 -> prPrec i 0 (concatD [prt 0 expression1, doc (showString ">"), prt 0 expression2])
    AbsKarel.Egeq expression1 expression2 -> prPrec i 0 (concatD [prt 0 expression1, doc (showString ">="), prt 0 expression2])
    AbsKarel.Esp expression1 expression2 -> prPrec i 0 (concatD [prt 0 expression1, doc (showString ">=<"), prt 0 expression2])
    AbsKarel.EAdd expression1 expression2 -> prPrec i 0 (concatD [prt 0 expression1, doc (showString "+"), prt 0 expression2])
    AbsKarel.ESub expression1 expression2 -> prPrec i 0 (concatD [prt 0 expression1, doc (showString "-"), prt 0 expression2])
    AbsKarel.EOR expression1 expression2 -> prPrec i 0 (concatD [prt 0 expression1, doc (showString "OR"), prt 0 expression2])
    AbsKarel.EPlus expression -> prPrec i 0 (concatD [doc (showString "+"), prt 0 expression])
    AbsKarel.EMinus expression -> prPrec i 0 (concatD [doc (showString "-"), prt 0 expression])
    AbsKarel.EMul expression1 expression2 -> prPrec i 0 (concatD [prt 0 expression1, doc (showString "*"), prt 0 expression2])
    AbsKarel.EAdiv expression1 expression2 -> prPrec i 0 (concatD [prt 0 expression1, doc (showString "/"), prt 0 expression2])
    AbsKarel.EAnd expression1 expression2 -> prPrec i 0 (concatD [prt 0 expression1, doc (showString "AND"), prt 0 expression2])
    AbsKarel.EMOD expression1 expression2 -> prPrec i 0 (concatD [prt 0 expression1, doc (showString "MOD"), prt 0 expression2])
    AbsKarel.EDiv expression1 expression2 -> prPrec i 0 (concatD [prt 0 expression1, doc (showString "DIV"), prt 0 expression2])
    AbsKarel.ENot expression1 expression2 -> prPrec i 0 (concatD [prt 0 expression1, doc (showString "NOT"), prt 0 expression2])
    AbsKarel.EDot expression1 expression2 -> prPrec i 0 (concatD [prt 0 expression1, doc (showString ":"), prt 0 expression2])
    AbsKarel.EAt expression1 expression2 -> prPrec i 0 (concatD [prt 0 expression1, doc (showString "@"), prt 0 expression2])
    AbsKarel.EHash expression1 expression2 -> prPrec i 0 (concatD [prt 0 expression1, doc (showString "#"), prt 0 expression2])
    AbsKarel.EIdent id_ -> prPrec i 0 (concatD [prt 0 id_])
    AbsKarel.EQString text -> prPrec i 0 (concatD [prt 0 text])
    AbsKarel.EDouble d -> prPrec i 0 (concatD [prt 0 d])
    AbsKarel.EInt n -> prPrec i 0 (concatD [prt 0 n])
    AbsKarel.EABS expression -> prPrec i 0 (concatD [doc (showString "ABS"), doc (showString "("), prt 0 expression, doc (showString ")")])
    AbsKarel.EACOS expression -> prPrec i 0 (concatD [doc (showString "ACOS"), doc (showString "("), prt 0 expression, doc (showString ")")])
    AbsKarel.EASIN expression -> prPrec i 0 (concatD [doc (showString "ASIN"), doc (showString "("), prt 0 expression, doc (showString ")")])
    AbsKarel.EATAN2 expression1 expression2 -> prPrec i 0 (concatD [doc (showString "ATAN2"), doc (showString "("), prt 0 expression1, doc (showString ","), prt 0 expression2, doc (showString ")")])
    AbsKarel.ECOS expression -> prPrec i 0 (concatD [doc (showString "COS"), doc (showString "("), prt 0 expression, doc (showString ")")])
    AbsKarel.ESin expression -> prPrec i 0 (concatD [doc (showString "SIN"), doc (showString "("), prt 0 expression, doc (showString ")")])
    AbsKarel.ETan expression -> prPrec i 0 (concatD [doc (showString "TAN"), doc (showString "("), prt 0 expression, doc (showString ")")])
    AbsKarel.ESqrt expression -> prPrec i 0 (concatD [doc (showString "SQRT"), doc (showString "("), prt 0 expression, doc (showString ")")])
    AbsKarel.ELn expression -> prPrec i 0 (concatD [doc (showString "LN"), doc (showString "("), prt 0 expression, doc (showString ")")])
    AbsKarel.EExp expression -> prPrec i 0 (concatD [doc (showString "EXP"), doc (showString "("), prt 0 expression, doc (showString ")")])
    AbsKarel.ETrunc expression -> prPrec i 0 (concatD [doc (showString "TRUNC"), doc (showString "("), prt 0 expression, doc (showString ")")])
    AbsKarel.ERound expression -> prPrec i 0 (concatD [doc (showString "ROUND"), doc (showString "("), prt 0 expression, doc (showString ")")])
    AbsKarel.EStrlen expression -> prPrec i 0 (concatD [doc (showString "STRLEN"), doc (showString "("), prt 0 expression, doc (showString ")")])
    AbsKarel.ESubstr expression1 expression2 expression3 -> prPrec i 0 (concatD [doc (showString "SUBSTR"), doc (showString "("), prt 0 expression1, doc (showString ","), prt 0 expression2, doc (showString ","), prt 0 expression3, doc (showString ")")])
    AbsKarel.EChr expression -> prPrec i 0 (concatD [doc (showString "CHR"), doc (showString "("), prt 0 expression, doc (showString ")")])
    AbsKarel.EOrd expression -> prPrec i 0 (concatD [doc (showString "ORD"), doc (showString "("), prt 0 expression, doc (showString ")")])
    AbsKarel.EUninitd expression -> prPrec i 0 (concatD [doc (showString "UNINIT"), doc (showString "("), prt 0 expression, doc (showString ")")])
    AbsKarel.ECurPos expression1 expression2 -> prPrec i 0 (concatD [doc (showString "CURPOS"), doc (showString "("), prt 0 expression1, doc (showString ","), prt 0 expression2, doc (showString ")")])
    AbsKarel.ECurJPos expression1 expression2 -> prPrec i 0 (concatD [doc (showString "CURJPOS"), doc (showString "("), prt 0 expression1, doc (showString ","), prt 0 expression2, doc (showString ")")])
    AbsKarel.EPosToJ expression1 expression2 -> prPrec i 0 (concatD [doc (showString "POS_TO_JPOS"), doc (showString "("), prt 0 expression1, doc (showString ","), prt 0 expression2, doc (showString ")")])
    AbsKarel.EJToPos expression1 expression2 -> prPrec i 0 (concatD [doc (showString "JPOS_TO_POS"), doc (showString "("), prt 0 expression1, doc (showString ","), prt 0 expression2, doc (showString ")")])

instance Print [AbsKarel.Expression] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 0 x]
  prt _ (x:xs) = concatD [prt 0 x, doc (showString ","), prt 0 xs]

instance Print AbsKarel.UserType where
  prt i = \case
    AbsKarel.UserTypeDT id_ datatypes -> prPrec i 0 (concatD [prt 0 id_, doc (showString "="), prt 0 datatypes])
    AbsKarel.UserTypeStruct id_ optlineend vardecls -> prPrec i 0 (concatD [doc (showString "STRUCTURE"), prt 0 id_, prt 0 optlineend, prt 0 vardecls, doc (showString "ENDSTRUCTURE")])

instance Print AbsKarel.Empty where
  prt i = \case
    AbsKarel.EmpyType -> prPrec i 0 (concatD [])

instance Print AbsKarel.MemTypes where
  prt i = \case
    AbsKarel.MemTypeDMOS -> prPrec i 0 (concatD [doc (showString "CMOS")])
    AbsKarel.MemTypeDRAM -> prPrec i 0 (concatD [doc (showString "DRAM")])
    AbsKarel.MemTypeEmpty empty -> prPrec i 0 (concatD [prt 0 empty])

instance Print AbsKarel.ReturnDataTypes where
  prt i = \case
    AbsKarel.RDTIdent id_ -> prPrec i 0 (concatD [prt 0 id_])
    AbsKarel.RDTChar c -> prPrec i 0 (concatD [prt 0 c])
    AbsKarel.RDTInt -> prPrec i 0 (concatD [doc (showString "INTEGER")])
    AbsKarel.RDTReal -> prPrec i 0 (concatD [doc (showString "REAL")])
    AbsKarel.RDTBool -> prPrec i 0 (concatD [doc (showString "BOOLEAN")])
    AbsKarel.RDTVector -> prPrec i 0 (concatD [doc (showString "VECTOR")])
    AbsKarel.RDTConfig -> prPrec i 0 (concatD [doc (showString "CONFIG")])
    AbsKarel.RDTCommon -> prPrec i 0 (concatD [doc (showString "COMMON_ASSOC")])
    AbsKarel.RDTPos positiondatatypes n -> prPrec i 0 (concatD [prt 0 positiondatatypes, doc (showString "IN"), doc (showString "GROUP"), doc (showString "["), prt 0 n, doc (showString "]")])
    AbsKarel.RDTString -> prPrec i 0 (concatD [doc (showString "STRING")])
    AbsKarel.RDTArray returnarrayindexs structuredarraytype -> prPrec i 0 (concatD [doc (showString "ARRAY"), doc (showString "["), prt 0 returnarrayindexs, doc (showString "]"), doc (showString "OF"), prt 0 structuredarraytype])

instance Print AbsKarel.ParameterDataTypes where
  prt i = \case
    AbsKarel.PDTIdent id_ -> prPrec i 0 (concatD [prt 0 id_])
    AbsKarel.PDTChar c -> prPrec i 0 (concatD [prt 0 c])
    AbsKarel.PDTInt -> prPrec i 0 (concatD [doc (showString "INTEGER")])
    AbsKarel.PDTReal -> prPrec i 0 (concatD [doc (showString "REAL")])
    AbsKarel.PDTBool -> prPrec i 0 (concatD [doc (showString "BOOLEAN")])
    AbsKarel.PDTVector -> prPrec i 0 (concatD [doc (showString "VECTOR")])
    AbsKarel.PDTVis -> prPrec i 0 (concatD [doc (showString "VIS_PROCESS")])
    AbsKarel.PDTModel -> prPrec i 0 (concatD [doc (showString "MODEL")])
    AbsKarel.PDTCam -> prPrec i 0 (concatD [doc (showString "CAM_SETUP")])
    AbsKarel.PDTFile -> prPrec i 0 (concatD [doc (showString "FILE")])
    AbsKarel.PDTConf -> prPrec i 0 (concatD [doc (showString "CONFIG")])
    AbsKarel.PDTPath pathdatatype -> prPrec i 0 (concatD [doc (showString "PATH"), prt 0 pathdatatype])
    AbsKarel.PDTCommon -> prPrec i 0 (concatD [doc (showString "COMMON_ASSOC")])
    AbsKarel.PDTPos positiondatatypes n -> prPrec i 0 (concatD [prt 0 positiondatatypes, doc (showString "IN"), doc (showString "GROUP"), doc (showString "["), prt 0 n, doc (showString "]")])
    AbsKarel.PDTString -> prPrec i 0 (concatD [doc (showString "STRING")])
    AbsKarel.PDTArray datatypes structuredarraytype -> prPrec i 0 (concatD [doc (showString "ARRAY"), doc (showString "["), prt 0 datatypes, doc (showString "]"), doc (showString "OF"), prt 0 structuredarraytype])

instance Print AbsKarel.DataTypes where
  prt i = \case
    AbsKarel.DTString n -> prPrec i 0 (concatD [doc (showString "STRING"), doc (showString "["), prt 0 n, doc (showString "]")])
    AbsKarel.DTArray arrayindexings structuredarraytype -> prPrec i 0 (concatD [doc (showString "ARRAY"), doc (showString "["), prt 0 arrayindexings, doc (showString "]"), doc (showString "OF"), prt 0 structuredarraytype])
    AbsKarel.DTStruct structuredarraytype -> prPrec i 0 (concatD [prt 0 structuredarraytype])
    AbsKarel.DTParam parameterdatatypes -> prPrec i 0 (concatD [prt 0 parameterdatatypes])

instance Print AbsKarel.StructuredArrayType where
  prt i = \case
    AbsKarel.SATShort -> prPrec i 0 (concatD [doc (showString "SHORT")])
    AbsKarel.SATByte -> prPrec i 0 (concatD [doc (showString "BYTE")])

instance Print AbsKarel.PathDataType where
  prt i = \case
    AbsKarel.PathDTHeader id_ -> prPrec i 0 (concatD [doc (showString "PATH"), doc (showString "HEADER"), doc (showString "="), prt 0 id_])
    AbsKarel.PathDTNode id_ -> prPrec i 0 (concatD [doc (showString "NODE"), doc (showString "DATA"), doc (showString "="), prt 0 id_])
    AbsKarel.PathDtEmpty empty -> prPrec i 0 (concatD [prt 0 empty])
    AbsKarel.PathDtHeaderExt id_1 id_2 -> prPrec i 0 (concatD [doc (showString "PATH"), doc (showString "HEADER"), doc (showString "="), prt 0 id_1, doc (showString ","), doc (showString "NODE"), doc (showString "DATA"), doc (showString "="), prt 0 id_2])

instance Print AbsKarel.PositionDataTypes where
  prt i = \case
    AbsKarel.PDTyPos -> prPrec i 0 (concatD [doc (showString "POSITION")])
    AbsKarel.PDTyXYZ -> prPrec i 0 (concatD [doc (showString "XYZWPR")])
    AbsKarel.PDTyJPos -> prPrec i 0 (concatD [doc (showString "JOINTPOS")])
    AbsKarel.PDTyJPos1 -> prPrec i 0 (concatD [doc (showString "JOINTPOS1")])
    AbsKarel.PDTyJPos2 -> prPrec i 0 (concatD [doc (showString "JOINTPOS2")])
    AbsKarel.PDTyJPos3 -> prPrec i 0 (concatD [doc (showString "JOINTPOS3")])
    AbsKarel.PDTyJPos4 -> prPrec i 0 (concatD [doc (showString "JOINTPOS4")])
    AbsKarel.PDTyJPos5 -> prPrec i 0 (concatD [doc (showString "JOINTPOS5")])
    AbsKarel.PDTyJPos6 -> prPrec i 0 (concatD [doc (showString "JOINTPOS6")])
    AbsKarel.PDTyJPos7 -> prPrec i 0 (concatD [doc (showString "JOINTPOS7")])
    AbsKarel.PDTyJPos8 -> prPrec i 0 (concatD [doc (showString "JOINTPOS8")])
    AbsKarel.PDTyJPos9 -> prPrec i 0 (concatD [doc (showString "JOINTPOS9")])
    AbsKarel.PDTyXYZEXT -> prPrec i 0 (concatD [doc (showString "XYZWPREXT")])
    AbsKarel.PDTyGAssoc -> prPrec i 0 (concatD [doc (showString "GROUP_ASSOC")])

instance Print AbsKarel.BoolDataTypes where
  prt i = \case
    AbsKarel.BDTTrue -> prPrec i 0 (concatD [doc (showString "TRUE")])
    AbsKarel.BDTFalse -> prPrec i 0 (concatD [doc (showString "FALSE")])

instance Print AbsKarel.ArrayIndexing where
  prt i = \case
    AbsKarel.IntArrayIndex n -> prPrec i 0 (concatD [prt 0 n])

instance Print [AbsKarel.ArrayIndexing] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 0 x]
  prt _ (x:xs) = concatD [prt 0 x, doc (showString ","), prt 0 xs]

instance Print AbsKarel.ReturnArrayIndex where
  prt i = \case
    AbsKarel.ReturnArrayInteger n -> prPrec i 0 (concatD [prt 0 n])
    AbsKarel.ReturnArrayAster -> prPrec i 0 (concatD [doc (showString "*")])

instance Print [AbsKarel.ReturnArrayIndex] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 0 x]
  prt _ (x:xs) = concatD [prt 0 x, doc (showString ","), prt 0 xs]

instance Print AbsKarel.Sign where
  prt i = \case
    AbsKarel.SignPlus -> prPrec i 0 (concatD [doc (showString "+")])
    AbsKarel.SignMinus -> prPrec i 0 (concatD [doc (showString "-")])
    AbsKarel.SignEmpty empty -> prPrec i 0 (concatD [prt 0 empty])

instance Print AbsKarel.Literal where
  prt i = \case
    AbsKarel.LiteralInteger n -> prPrec i 0 (concatD [prt 0 n])
    AbsKarel.LiteralDouble d -> prPrec i 0 (concatD [prt 0 d])
    AbsKarel.LiteralQuoted text -> prPrec i 0 (concatD [prt 0 text])

instance Print AbsKarel.Text where
  prt i = \case
    AbsKarel.TextString str -> prPrec i 0 (concatD [printString str])
    AbsKarel.TextQuotedString quotedstring -> prPrec i 0 (concatD [prt 0 quotedstring])

instance Print AbsKarel.Constant where
  prt i = \case
    AbsKarel.ConstLiteral literal -> prPrec i 0 (concatD [prt 0 literal])
    AbsKarel.ConstIdent id_ -> prPrec i 0 (concatD [prt 0 id_])

instance Print AbsKarel.OptLineEnd where
  prt i = \case
    AbsKarel.OptLineEndLineEnd lineend -> prPrec i 0 (concatD [prt 0 lineend])
    AbsKarel.OptLineEndEmpty empty -> prPrec i 0 (concatD [prt 0 empty])
