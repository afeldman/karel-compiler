-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.6.1).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -Wno-incomplete-patterns -Wno-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module ParKarel
  ( happyError
  , myLexer
  , pKarel
  , pDirectiveBlock
  , pListDirectiveBlock
  , pErrorCommandBlock
  , pErrorCommandTPBlock
  , pDeclBlock
  , pListDeclBlock
  , pConstDeclBlock
  , pConstDecl
  , pListConstDecl
  , pTypeDeclBlock
  , pTypeDecl
  , pListTypeDecl
  , pVarDeclBlock
  , pVarDecl
  , pListVarDecl
  , pRoutineDeclBlock
  , pRoutineParameter
  , pParameterField
  , pListParameterField
  , pParamIdent
  , pListParamIdent
  , pRoutineDefinitionBlock
  , pListRoutineDefinitionBlock
  , pFromBlock
  , pGlobalCondition
  , pGlobalConditionSelect
  , pGlobalConditionBool
  , pGlobalConditionVarSelect
  , pConditionHandlerAction
  , pListConditionHandlerAction
  , pStm
  , pConditionWhenStm
  , pConditionWithStm
  , pListConditionWithStm
  , pGlobalConditionList
  , pGroups
  , pListStm
  , pWaitSelect
  , pCaseStm
  , pListCaseStm
  , pVarAccess
  , pListVarAccess
  , pReadItem
  , pListReadItem
  , pWriteItem
  , pListWriteItem
  , pFormatSpec
  , pCR
  , pPulseOut
  , pNwait
  , pExpression
  , pListExpression
  , pUserType
  , pEmpty
  , pMemTypes
  , pReturnDataTypes
  , pParameterDataTypes
  , pDataTypes
  , pStructuredArrayType
  , pPathDataType
  , pPositionDataTypes
  , pBoolDataTypes
  , pArrayIndexing
  , pListArrayIndexing
  , pReturnArrayIndex
  , pListReturnArrayIndex
  , pSign
  , pLiteral
  , pText
  , pConstant
  , pOptLineEnd
  ) where

import Prelude

import qualified AbsKarel
import LexKarel

}

%name pKarel Karel
%name pDirectiveBlock DirectiveBlock
%name pListDirectiveBlock ListDirectiveBlock
%name pErrorCommandBlock ErrorCommandBlock
%name pErrorCommandTPBlock ErrorCommandTPBlock
%name pDeclBlock DeclBlock
%name pListDeclBlock ListDeclBlock
%name pConstDeclBlock ConstDeclBlock
%name pConstDecl ConstDecl
%name pListConstDecl ListConstDecl
%name pTypeDeclBlock TypeDeclBlock
%name pTypeDecl TypeDecl
%name pListTypeDecl ListTypeDecl
%name pVarDeclBlock VarDeclBlock
%name pVarDecl VarDecl
%name pListVarDecl ListVarDecl
%name pRoutineDeclBlock RoutineDeclBlock
%name pRoutineParameter RoutineParameter
%name pParameterField ParameterField
%name pListParameterField ListParameterField
%name pParamIdent ParamIdent
%name pListParamIdent ListParamIdent
%name pRoutineDefinitionBlock RoutineDefinitionBlock
%name pListRoutineDefinitionBlock ListRoutineDefinitionBlock
%name pFromBlock FromBlock
%name pGlobalCondition GlobalCondition
%name pGlobalConditionSelect GlobalConditionSelect
%name pGlobalConditionBool GlobalConditionBool
%name pGlobalConditionVarSelect GlobalConditionVarSelect
%name pConditionHandlerAction ConditionHandlerAction
%name pListConditionHandlerAction ListConditionHandlerAction
%name pStm Stm
%name pConditionWhenStm ConditionWhenStm
%name pConditionWithStm ConditionWithStm
%name pListConditionWithStm ListConditionWithStm
%name pGlobalConditionList GlobalConditionList
%name pGroups Groups
%name pListStm ListStm
%name pWaitSelect WaitSelect
%name pCaseStm CaseStm
%name pListCaseStm ListCaseStm
%name pVarAccess VarAccess
%name pListVarAccess ListVarAccess
%name pReadItem ReadItem
%name pListReadItem ListReadItem
%name pWriteItem WriteItem
%name pListWriteItem ListWriteItem
%name pFormatSpec FormatSpec
%name pCR CR
%name pPulseOut PulseOut
%name pNwait Nwait
%name pExpression Expression
%name pListExpression ListExpression
%name pUserType UserType
%name pEmpty Empty
%name pMemTypes MemTypes
%name pReturnDataTypes ReturnDataTypes
%name pParameterDataTypes ParameterDataTypes
%name pDataTypes DataTypes
%name pStructuredArrayType StructuredArrayType
%name pPathDataType PathDataType
%name pPositionDataTypes PositionDataTypes
%name pBoolDataTypes BoolDataTypes
%name pArrayIndexing ArrayIndexing
%name pListArrayIndexing ListArrayIndexing
%name pReturnArrayIndex ReturnArrayIndex
%name pListReturnArrayIndex ListReturnArrayIndex
%name pSign Sign
%name pLiteral Literal
%name pText Text
%name pConstant Constant
%name pOptLineEnd OptLineEnd
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '#'                 { PT _ (TS _ 1)            }
  '%ALPHABETIZE'      { PT _ (TS _ 2)            }
  '%CMOSVARS'         { PT _ (TS _ 3)            }
  '%COMMENT'          { PT _ (TS _ 4)            }
  '%CRTDEVICE'        { PT _ (TS _ 5)            }
  '%DEFGROUP'         { PT _ (TS _ 6)            }
  '%DEFINE'           { PT _ (TS _ 7)            }
  '%DELAY'            { PT _ (TS _ 8)            }
  '%ELSE'             { PT _ (TS _ 9)            }
  '%ENDIF'            { PT _ (TS _ 10)           }
  '%ENVIRONMENT'      { PT _ (TS _ 11)           }
  '%IF'               { PT _ (TS _ 12)           }
  '%IFDEF'            { PT _ (TS _ 13)           }
  '%IFNDEF'           { PT _ (TS _ 14)           }
  '%INCLUDE'          { PT _ (TS _ 15)           }
  '%LOCKGROUP'        { PT _ (TS _ 16)           }
  '%NOABORT'          { PT _ (TS _ 17)           }
  '%NOBUSYLAMP'       { PT _ (TS _ 18)           }
  '%NOLOCKGROUP'      { PT _ (TS _ 19)           }
  '%NOPAUSE'          { PT _ (TS _ 20)           }
  '%NOPAUSESHFT'      { PT _ (TS _ 21)           }
  '%PRIORITY'         { PT _ (TS _ 22)           }
  '%STACKSIZE'        { PT _ (TS _ 23)           }
  '%TIMESLICE'        { PT _ (TS _ 24)           }
  '%TPMOTION'         { PT _ (TS _ 25)           }
  '%UNDEF'            { PT _ (TS _ 26)           }
  '('                 { PT _ (TS _ 27)           }
  ')'                 { PT _ (TS _ 28)           }
  '*'                 { PT _ (TS _ 29)           }
  '+'                 { PT _ (TS _ 30)           }
  ','                 { PT _ (TS _ 31)           }
  '-'                 { PT _ (TS _ 32)           }
  '.'                 { PT _ (TS _ 33)           }
  '..'                { PT _ (TS _ 34)           }
  '/'                 { PT _ (TS _ 35)           }
  ':'                 { PT _ (TS _ 36)           }
  '::'                { PT _ (TS _ 37)           }
  ';'                 { PT _ (TS _ 38)           }
  '<'                 { PT _ (TS _ 39)           }
  '<='                { PT _ (TS _ 40)           }
  '<>'                { PT _ (TS _ 41)           }
  '='                 { PT _ (TS _ 42)           }
  '>'                 { PT _ (TS _ 43)           }
  '>='                { PT _ (TS _ 44)           }
  '>=<'               { PT _ (TS _ 45)           }
  '@'                 { PT _ (TS _ 46)           }
  'ABORT'             { PT _ (TS _ 47)           }
  'ABS'               { PT _ (TS _ 48)           }
  'ACOS'              { PT _ (TS _ 49)           }
  'ACTIVATE_SCREEN'   { PT _ (TS _ 50)           }
  'AND'               { PT _ (TS _ 51)           }
  'ARRAY'             { PT _ (TS _ 52)           }
  'ASIN'              { PT _ (TS _ 53)           }
  'ATAN2'             { PT _ (TS _ 54)           }
  'ATTACH'            { PT _ (TS _ 55)           }
  'BEGIN'             { PT _ (TS _ 56)           }
  'BOOLEAN'           { PT _ (TS _ 57)           }
  'BYTE'              { PT _ (TS _ 58)           }
  'CAM_SETUP'         { PT _ (TS _ 59)           }
  'CANCEL'            { PT _ (TS _ 60)           }
  'CASE'              { PT _ (TS _ 61)           }
  'CHR'               { PT _ (TS _ 62)           }
  'CIRCULAR'          { PT _ (TS _ 63)           }
  'CLOSE'             { PT _ (TS _ 64)           }
  'CLR_TPE_STAT'      { PT _ (TS _ 65)           }
  'CMOS'              { PT _ (TS _ 66)           }
  'COMMAND'           { PT _ (TS _ 67)           }
  'COMMON_ASSOC'      { PT _ (TS _ 68)           }
  'CONDITION'         { PT _ (TS _ 69)           }
  'CONFIG'            { PT _ (TS _ 70)           }
  'CONNECT'           { PT _ (TS _ 71)           }
  'CONST'             { PT _ (TS _ 72)           }
  'CONTINUE'          { PT _ (TS _ 73)           }
  'COS'               { PT _ (TS _ 74)           }
  'CR'                { PT _ (TS _ 75)           }
  'CURJPOS'           { PT _ (TS _ 76)           }
  'CURPOS'            { PT _ (TS _ 77)           }
  'DATA'              { PT _ (TS _ 78)           }
  'DEACTIVATE_SCREEN' { PT _ (TS _ 79)           }
  'DELAY'             { PT _ (TS _ 80)           }
  'DISABLE'           { PT _ (TS _ 81)           }
  'DISCONNECT'        { PT _ (TS _ 82)           }
  'DIV'               { PT _ (TS _ 83)           }
  'DO'                { PT _ (TS _ 84)           }
  'DOUT'              { PT _ (TS _ 85)           }
  'DOWNTO'            { PT _ (TS _ 86)           }
  'DRAM'              { PT _ (TS _ 87)           }
  'EDNIF'             { PT _ (TS _ 88)           }
  'ELSE'              { PT _ (TS _ 89)           }
  'ENABLE'            { PT _ (TS _ 90)           }
  'END'               { PT _ (TS _ 91)           }
  'ENDCONDITION'      { PT _ (TS _ 92)           }
  'ENDFOR'            { PT _ (TS _ 93)           }
  'ENDIF'             { PT _ (TS _ 94)           }
  'ENDSELECT'         { PT _ (TS _ 95)           }
  'ENDSTRUCTURE'      { PT _ (TS _ 96)           }
  'ENDUSING'          { PT _ (TS _ 97)           }
  'ENDWHILE'          { PT _ (TS _ 98)           }
  'ERROR'             { PT _ (TS _ 99)           }
  'EVAL'              { PT _ (TS _ 100)          }
  'EVENT'             { PT _ (TS _ 101)          }
  'EXP'               { PT _ (TS _ 102)          }
  'FALSE'             { PT _ (TS _ 103)          }
  'FILE'              { PT _ (TS _ 104)          }
  'FOR'               { PT _ (TS _ 105)          }
  'FROM'              { PT _ (TS _ 106)          }
  'GET_JPOS_REG'      { PT _ (TS _ 107)          }
  'GET_PORT'          { PT _ (TS _ 108)          }
  'GET_POS_REG'       { PT _ (TS _ 109)          }
  'GET_POS_TPE'       { PT _ (TS _ 110)          }
  'GET_REG'           { PT _ (TS _ 111)          }
  'GET_TPE_PRM'       { PT _ (TS _ 112)          }
  'GET_VAR'           { PT _ (TS _ 113)          }
  'GO'                { PT _ (TS _ 114)          }
  'GOTO'              { PT _ (TS _ 115)          }
  'GROUP'             { PT _ (TS _ 116)          }
  'GROUP_ASSOC'       { PT _ (TS _ 117)          }
  'HAND'              { PT _ (TS _ 118)          }
  'HEADER'            { PT _ (TS _ 119)          }
  'HOLD'              { PT _ (TS _ 120)          }
  'IF'                { PT _ (TS _ 121)          }
  'IN'                { PT _ (TS _ 122)          }
  'INTEGER'           { PT _ (TS _ 123)          }
  'JOINT'             { PT _ (TS _ 124)          }
  'JOINTPOS'          { PT _ (TS _ 125)          }
  'JOINTPOS1'         { PT _ (TS _ 126)          }
  'JOINTPOS2'         { PT _ (TS _ 127)          }
  'JOINTPOS3'         { PT _ (TS _ 128)          }
  'JOINTPOS4'         { PT _ (TS _ 129)          }
  'JOINTPOS5'         { PT _ (TS _ 130)          }
  'JOINTPOS6'         { PT _ (TS _ 131)          }
  'JOINTPOS7'         { PT _ (TS _ 132)          }
  'JOINTPOS8'         { PT _ (TS _ 133)          }
  'JOINTPOS9'         { PT _ (TS _ 134)          }
  'JPOS_TO_POS'       { PT _ (TS _ 135)          }
  'LINEAR'            { PT _ (TS _ 136)          }
  'LN'                { PT _ (TS _ 137)          }
  'MOD'               { PT _ (TS _ 138)          }
  'MODEL'             { PT _ (TS _ 139)          }
  'MOVE'              { PT _ (TS _ 140)          }
  'MSG_OK'            { PT _ (TS _ 141)          }
  'NOABORT'           { PT _ (TS _ 142)          }
  'NODE'              { PT _ (TS _ 143)          }
  'NOMESSAGE'         { PT _ (TS _ 144)          }
  'NOPAUSE'           { PT _ (TS _ 145)          }
  'NOT'               { PT _ (TS _ 146)          }
  'NOWAIT'            { PT _ (TS _ 147)          }
  'OF'                { PT _ (TS _ 148)          }
  'OPEN'              { PT _ (TS _ 149)          }
  'OR'                { PT _ (TS _ 150)          }
  'ORD'               { PT _ (TS _ 151)          }
  'PATH'              { PT _ (TS _ 152)          }
  'PAUSE'             { PT _ (TS _ 153)          }
  'POSITION'          { PT _ (TS _ 154)          }
  'POS_TO_JPOS'       { PT _ (TS _ 155)          }
  'POWERUP'           { PT _ (TS _ 156)          }
  'PROGRAM'           { PT _ (TS _ 157)          }
  'PULSE'             { PT _ (TS _ 158)          }
  'PURGE'             { PT _ (TS _ 159)          }
  'RDO'               { PT _ (TS _ 160)          }
  'READ'              { PT _ (TS _ 161)          }
  'REAL'              { PT _ (TS _ 162)          }
  'RELAX'             { PT _ (TS _ 163)          }
  'RELEASE'           { PT _ (TS _ 164)          }
  'REPEAT'            { PT _ (TS _ 165)          }
  'RESTORE'           { PT _ (TS _ 166)          }
  'RESUM'             { PT _ (TS _ 167)          }
  'RESUME'            { PT _ (TS _ 168)          }
  'RETURN'            { PT _ (TS _ 169)          }
  'ROUND'             { PT _ (TS _ 170)          }
  'ROUTINE'           { PT _ (TS _ 171)          }
  'SELECT'            { PT _ (TS _ 172)          }
  'SEMAPHORE'         { PT _ (TS _ 173)          }
  'SET_JPOS_REG'      { PT _ (TS _ 174)          }
  'SET_PORT'          { PT _ (TS _ 175)          }
  'SET_POS_REG'       { PT _ (TS _ 176)          }
  'SET_POS_TPE'       { PT _ (TS _ 177)          }
  'SET_REG'           { PT _ (TS _ 178)          }
  'SET_TPE_PRM'       { PT _ (TS _ 179)          }
  'SET_VAR'           { PT _ (TS _ 180)          }
  'SHORT'             { PT _ (TS _ 181)          }
  'SIGNAL'            { PT _ (TS _ 182)          }
  'SIN'               { PT _ (TS _ 183)          }
  'SQRT'              { PT _ (TS _ 184)          }
  'STOP'              { PT _ (TS _ 185)          }
  'STRING'            { PT _ (TS _ 186)          }
  'STRLEN'            { PT _ (TS _ 187)          }
  'STRUCTURE'         { PT _ (TS _ 188)          }
  'SUBSTR'            { PT _ (TS _ 189)          }
  'TAN'               { PT _ (TS _ 190)          }
  'THEN'              { PT _ (TS _ 191)          }
  'TIMER'             { PT _ (TS _ 192)          }
  'TO'                { PT _ (TS _ 193)          }
  'TPENABLE'          { PT _ (TS _ 194)          }
  'TRUE'              { PT _ (TS _ 195)          }
  'TRUNC'             { PT _ (TS _ 196)          }
  'TYPE'              { PT _ (TS _ 197)          }
  'UNHOLD'            { PT _ (TS _ 198)          }
  'UNINIT'            { PT _ (TS _ 199)          }
  'UNPAUSE'           { PT _ (TS _ 200)          }
  'UNTIL'             { PT _ (TS _ 201)          }
  'USING'             { PT _ (TS _ 202)          }
  'VAR'               { PT _ (TS _ 203)          }
  'VECTOR'            { PT _ (TS _ 204)          }
  'VIA'               { PT _ (TS _ 205)          }
  'VIS_PROCESS'       { PT _ (TS _ 206)          }
  'WAIT'              { PT _ (TS _ 207)          }
  'WHEN'              { PT _ (TS _ 208)          }
  'WHILE'             { PT _ (TS _ 209)          }
  'WITH'              { PT _ (TS _ 210)          }
  'WRITE'             { PT _ (TS _ 211)          }
  'XYZWPR'            { PT _ (TS _ 212)          }
  'XYZWPREXT'         { PT _ (TS _ 213)          }
  '['                 { PT _ (TS _ 214)          }
  ']'                 { PT _ (TS _ 215)          }
  L_Ident             { PT _ (TV $$)             }
  L_charac            { PT _ (TC $$)             }
  L_doubl             { PT _ (TD $$)             }
  L_integ             { PT _ (TI $$)             }
  L_quoted            { PT _ (TL $$)             }
  L_QuotedString      { PT _ (T_QuotedString $$) }
  L_LineEnd           { PT _ (T_LineEnd $$)      }

%%

Ident :: { AbsKarel.Ident }
Ident  : L_Ident { AbsKarel.Ident $1 }

Char    :: { Char }
Char     : L_charac { (read $1) :: Char }

Double  :: { Double }
Double   : L_doubl  { (read $1) :: Double }

Integer :: { Integer }
Integer  : L_integ  { (read $1) :: Integer }

String  :: { String }
String   : L_quoted { $1 }

QuotedString :: { AbsKarel.QuotedString }
QuotedString  : L_QuotedString { AbsKarel.QuotedString $1 }

LineEnd :: { AbsKarel.LineEnd }
LineEnd  : L_LineEnd { AbsKarel.LineEnd $1 }

Karel :: { AbsKarel.Karel }
Karel
  : 'PROGRAM' Ident OptLineEnd ListDirectiveBlock ListDeclBlock 'BEGIN' ListStm 'END' Ident ListRoutineDefinitionBlock { AbsKarel.KarelGrammer $2 $3 $4 $5 $7 $9 $10 }

DirectiveBlock :: { AbsKarel.DirectiveBlock }
DirectiveBlock
  : '%ALPHABETIZE' { AbsKarel.DirAlphabet }
  | '%CMOSVARS' { AbsKarel.DirCMOS }
  | '%CRTDEVICE' { AbsKarel.DirCRT }
  | '%NOBUSYLAMP' { AbsKarel.DirNoBusy }
  | '%NOLOCKGROUP' { AbsKarel.DirNoLock }
  | '%NOPAUSESHFT' { AbsKarel.DirNoPauseS }
  | '%TPMOTION' { AbsKarel.DirRPMotion }
  | '%COMMENT' '=' Text { AbsKarel.DirComment $3 }
  | '%DEFGROUP' '=' Integer { AbsKarel.DirDefGroup $3 }
  | '%DELAY' '=' Integer { AbsKarel.DirDelay $3 }
  | '%PRIORITY' '=' Integer { AbsKarel.DirProp $3 }
  | '%STACKSIZE' '=' Integer { AbsKarel.DirStackSiz $3 }
  | '%TIMESLICE' '=' Integer { AbsKarel.DirTimeSliz $3 }
  | '%ENVIRONMENT' '=' Ident { AbsKarel.DirEnv $3 }
  | '%LOCKGROUP' '=' ListArrayIndexing { AbsKarel.DirLock $3 }
  | '%NOABORT' '=' ErrorCommandBlock { AbsKarel.DirNoAbort $3 }
  | '%NOPAUSE' '=' ErrorCommandTPBlock { AbsKarel.DirNoPause $3 }
  | '%INCLUDE' Text { AbsKarel.DirInclude $2 }
  | '%DEFINE' Ident Expression { AbsKarel.DirDefine $2 $3 }
  | '%DEFINE' Ident Integer { AbsKarel.DirDefineConst $2 $3 }
  | '%UNDEF' Ident { AbsKarel.DirUndef $2 }
  | '%IFDEF' Ident { AbsKarel.DirIfdef $2 }
  | '%IFNDEF' Ident { AbsKarel.DirIfndef $2 }
  | '%IF' Expression { AbsKarel.DirIf $2 }
  | '%ELSE' { AbsKarel.DirElse }
  | '%ENDIF' { AbsKarel.DirEndif }

ListDirectiveBlock :: { [AbsKarel.DirectiveBlock] }
ListDirectiveBlock
  : {- empty -} { [] }
  | DirectiveBlock ListDirectiveBlock { (:) $1 $2 }

ErrorCommandBlock :: { AbsKarel.ErrorCommandBlock }
ErrorCommandBlock
  : 'COMMAND' { AbsKarel.ECBCom }
  | 'ERROR' { AbsKarel.ECBError }
  | 'ERROR' '+' 'COMMAND' { AbsKarel.ECBECom }

ErrorCommandTPBlock :: { AbsKarel.ErrorCommandTPBlock }
ErrorCommandTPBlock
  : ErrorCommandBlock { AbsKarel.ECTBECB $1 }
  | 'COMMAND' '+' 'TPENABLE' { AbsKarel.ECTBCom }
  | 'ERROR' '+' 'TPENABLE' { AbsKarel.ECTBErr }
  | 'ERROR' '+' 'COMMAND' '+' 'TPENABLE' { AbsKarel.ECTBAnable }

DeclBlock :: { AbsKarel.DeclBlock }
DeclBlock
  : ConstDeclBlock { AbsKarel.DeclConst $1 }
  | TypeDeclBlock { AbsKarel.DeclType $1 }
  | VarDeclBlock { AbsKarel.DeclVar $1 }
  | RoutineDeclBlock { AbsKarel.DeclRoutine $1 }

ListDeclBlock :: { [AbsKarel.DeclBlock] }
ListDeclBlock
  : {- empty -} { [] } | DeclBlock ListDeclBlock { (:) $1 $2 }

ConstDeclBlock :: { AbsKarel.ConstDeclBlock }
ConstDeclBlock
  : 'CONST' OptLineEnd ListConstDecl { AbsKarel.CDB $2 $3 }

ConstDecl :: { AbsKarel.ConstDecl }
ConstDecl
  : Ident '=' Ident OptLineEnd { AbsKarel.CDIdent $1 $3 $4 }
  | Ident '=' Literal OptLineEnd { AbsKarel.CDLiteral $1 $3 $4 }

ListConstDecl :: { [AbsKarel.ConstDecl] }
ListConstDecl
  : {- empty -} { [] } | ConstDecl ListConstDecl { (:) $1 $2 }

TypeDeclBlock :: { AbsKarel.TypeDeclBlock }
TypeDeclBlock
  : 'TYPE' OptLineEnd ListTypeDecl { AbsKarel.TCB $2 $3 }

TypeDecl :: { AbsKarel.TypeDecl }
TypeDecl
  : Ident 'FROM' Ident UserType OptLineEnd { AbsKarel.TDeclU $1 $3 $4 $5 }
  | Ident '=' UserType OptLineEnd { AbsKarel.TUser $1 $3 $4 }
  | UserType OptLineEnd { AbsKarel.TUserD $1 $2 }

ListTypeDecl :: { [AbsKarel.TypeDecl] }
ListTypeDecl
  : TypeDecl { (:[]) $1 } | TypeDecl ListTypeDecl { (:) $1 $2 }

VarDeclBlock :: { AbsKarel.VarDeclBlock }
VarDeclBlock : 'VAR' OptLineEnd ListVarDecl { AbsKarel.VDB $2 $3 }

VarDecl :: { AbsKarel.VarDecl }
VarDecl
  : Ident ',' OptLineEnd VarDecl { AbsKarel.VarDIden $1 $3 $4 }
  | Ident MemTypes FromBlock ':' DataTypes { AbsKarel.VarDDtype $1 $2 $3 $5 }

ListVarDecl :: { [AbsKarel.VarDecl] }
ListVarDecl
  : {- empty -} { [] } | VarDecl ListVarDecl { (:) $1 $2 }

RoutineDeclBlock :: { AbsKarel.RoutineDeclBlock }
RoutineDeclBlock
  : 'ROUTINE' Ident RoutineParameter FromBlock { AbsKarel.RoutineDeclarationBlock $2 $3 $4 }

RoutineParameter :: { AbsKarel.RoutineParameter }
RoutineParameter
  : '(' ListParameterField ')' { AbsKarel.RoutineParamBrack $2 }
  | '(' ListParameterField ')' ':' ReturnDataTypes { AbsKarel.RoutineReturn $2 $5 }

ParameterField :: { AbsKarel.ParameterField }
ParameterField
  : ParamIdent ':' ParameterDataTypes { AbsKarel.ParamFieldIdent $1 $3 }
  | ParamIdent ',' ListParamIdent ':' ParameterDataTypes { AbsKarel.ParamFieldDecl $1 $3 $5 }
  | ParamIdent ',' ListParamIdent ':' ParameterDataTypes '=' Expression { AbsKarel.ParamDefaultDecl $1 $3 $5 $7 }

ListParameterField :: { [AbsKarel.ParameterField] }
ListParameterField
  : {- empty -} { [] }
  | ParameterField { (:[]) $1 }
  | ParameterField ';' ListParameterField { (:) $1 $3 }

ParamIdent :: { AbsKarel.ParamIdent }
ParamIdent : Ident { AbsKarel.ParamType $1 }

ListParamIdent :: { [AbsKarel.ParamIdent] }
ListParamIdent
  : ParamIdent { (:[]) $1 }
  | ParamIdent ',' ListParamIdent { (:) $1 $3 }

RoutineDefinitionBlock :: { AbsKarel.RoutineDefinitionBlock }
RoutineDefinitionBlock
  : 'ROUTINE' Ident OptLineEnd ListDeclBlock 'BEGIN' ListStm 'END' Ident { AbsKarel.RoutineDefineBlock $2 $3 $4 $6 $8 }

ListRoutineDefinitionBlock :: { [AbsKarel.RoutineDefinitionBlock] }
ListRoutineDefinitionBlock
  : {- empty -} { [] }
  | RoutineDefinitionBlock ListRoutineDefinitionBlock { (:) $1 $2 }

FromBlock :: { AbsKarel.FromBlock }
FromBlock
  : 'FROM' Ident { AbsKarel.FromBIdent $2 }
  | Empty { AbsKarel.FromBEmpty $1 }

GlobalCondition :: { AbsKarel.GlobalCondition }
GlobalCondition
  : '(' GlobalCondition ')' { AbsKarel.GCBase $2 }
  | 'ERROR' '[' ListArrayIndexing ']' { AbsKarel.GCError $3 }
  | 'EVENT' '[' ListArrayIndexing ']' { AbsKarel.GCEvent $3 }
  | 'SEMAPHORE' '[' ListArrayIndexing ']' { AbsKarel.GCSemaphore $3 }
  | 'POWERUP' { AbsKarel.GCPowerUp }
  | 'ABORT' GlobalConditionSelect { AbsKarel.GCAbort $2 }
  | 'PAUSE' GlobalConditionSelect { AbsKarel.GCPause $2 }
  | 'CONTINUE' GlobalConditionSelect { AbsKarel.GCCONTINUE $2 }
  | GlobalConditionBool { AbsKarel.GCVarAccess $1 }
  | Ident '[' Expression ']' Sign { AbsKarel.GCPortCond $1 $3 $5 }
  | 'NOT' Ident '[' Expression ']' Sign { AbsKarel.GCNotPortCond $2 $4 $6 }

GlobalConditionSelect :: { AbsKarel.GlobalConditionSelect }
GlobalConditionSelect
  : 'PROGRAM' '[' Expression ']' { AbsKarel.GCSProg $3 }
  | Empty { AbsKarel.GCSEmpty $1 }

GlobalConditionBool :: { AbsKarel.GlobalConditionBool }
GlobalConditionBool
  : Ident '=' GlobalConditionVarSelect { AbsKarel.GCBEqual $1 $3 }
  | Ident '<>' GlobalConditionVarSelect { AbsKarel.GCBNEqual $1 $3 }
  | Ident '<' GlobalConditionVarSelect { AbsKarel.GCBLess $1 $3 }
  | Ident '<=' GlobalConditionVarSelect { AbsKarel.GCBLessEQ $1 $3 }
  | Ident '>' GlobalConditionVarSelect { AbsKarel.GCBGread $1 $3 }
  | Ident '>=' GlobalConditionVarSelect { AbsKarel.GCBGEQ $1 $3 }

GlobalConditionVarSelect :: { AbsKarel.GlobalConditionVarSelect }
GlobalConditionVarSelect
  : Constant { AbsKarel.GCVSBase $1 }
  | 'EVAL' '(' Expression ')' { AbsKarel.GCVSEval $3 }

ConditionHandlerAction :: { AbsKarel.ConditionHandlerAction }
ConditionHandlerAction
  : Empty { AbsKarel.CHAEmpty $1 }
  | 'NOABORT' { AbsKarel.CHANoAbort }
  | 'NOPAUSE' { AbsKarel.CHANoPause }
  | 'UNPAUSE' { AbsKarel.CHAUnPause }
  | 'NOMESSAGE' { AbsKarel.CHANoMessage }
  | 'RESTORE' { AbsKarel.CHARestore }
  | 'HOLD' Groups { AbsKarel.CHAHold $2 }
  | 'UNHOLD' Groups { AbsKarel.CHAUnHold $2 }
  | 'RESUME' Groups { AbsKarel.CHAResum $2 }
  | 'STOP' Groups { AbsKarel.CHAStop $2 }
  | 'CANCEL' Groups { AbsKarel.CHACancel $2 }
  | 'ENABLE' 'CONDITION' '[' Expression ']' { AbsKarel.CHAEnable $4 }
  | 'DISABLE' 'CONDITION' '[' Expression ']' { AbsKarel.CHADisable $4 }
  | 'SIGNAL' 'EVENT' '[' Expression ']' { AbsKarel.CHASignalEvent $4 }
  | 'SIGNAL' 'SEMAPHORE' '[' Expression ']' { AbsKarel.CHASignalSema $4 }
  | Ident { AbsKarel.CHAIdent $1 }
  | 'PULSE' PulseOut '[' Expression ']' 'FOR' Integer { AbsKarel.CHAPulse $2 $4 $7 }
  | 'ABORT' { AbsKarel.CHAAbort }
  | 'ABORT' 'PROGRAM' '[' Expression ']' { AbsKarel.CHAAbortProg $4 }
  | 'CONTINUE' { AbsKarel.CHAContinue }
  | 'CONTINUE' 'PROGRAM' '[' Expression ']' { AbsKarel.CHAContProg $4 }
  | 'PAUSE' { AbsKarel.CHAPause }
  | 'PAUSE' 'PROGRAM' '[' Expression ']' { AbsKarel.CHAPauseProg $4 }
  | VarAccess '=' Ident '[' Expression ']' { AbsKarel.CHAVarAccess $1 $3 $5 }
  | VarAccess '=' 'EVAL' '(' Expression ')' { AbsKarel.CHAVarAccEval $1 $5 }
  | VarAccess '=' Constant { AbsKarel.CHAVarAccConst $1 $3 }
  | Integer '[' Expression ']' '=' VarAccess { AbsKarel.CHAPortVA $1 $3 $6 }
  | Integer '[' Expression ']' '=' 'EVAL' '(' Expression ')' { AbsKarel.CHAPortEval $1 $3 $8 }

ListConditionHandlerAction :: { [AbsKarel.ConditionHandlerAction] }
ListConditionHandlerAction
  : {- empty -} { [] }
  | ConditionHandlerAction ',' ListConditionHandlerAction { (:) $1 $3 }

Stm :: { AbsKarel.Stm }
Stm
  : 'ATTACH' { AbsKarel.SAttach }
  | 'RELEASE' { AbsKarel.SRelease }
  | 'ABORT' { AbsKarel.SAbort }
  | 'ABORT' 'PROGRAM' '[' ListArrayIndexing ']' { AbsKarel.SAbortP $4 }
  | Ident '=' Expression { AbsKarel.SAssign $1 $3 }
  | 'CLOSE' 'FILE' Ident { AbsKarel.SCloseFile $3 }
  | 'CLOSE' 'HAND' Integer { AbsKarel.SCloseHand $3 }
  | 'DELAY' Integer { AbsKarel.SDelay $2 }
  | 'CONNECT' 'TIMER' 'TO' Integer { AbsKarel.SConnect $4 }
  | 'DISABLE' 'CONDITION' '[' ListArrayIndexing ']' { AbsKarel.SDisable $4 }
  | 'DISCONNECT' 'TIMER' Integer { AbsKarel.SDisconectT $3 }
  | 'ENABLE' 'CONDITION' '[' ListArrayIndexing ']' { AbsKarel.SEnable $4 }
  | 'OPEN' 'HAND' Integer { AbsKarel.SOpenHand $3 }
  | 'PURGE' 'CONDITION' '[' ListArrayIndexing ']' { AbsKarel.SPurge $4 }
  | 'RELAX' 'HAND' Integer { AbsKarel.SRelax $3 }
  | 'SIGNAL' 'EVENT' '[' ListArrayIndexing ']' { AbsKarel.SSignal $4 }
  | 'CANCEL' { AbsKarel.SCancel }
  | 'CANCEL' 'FILE' Ident { AbsKarel.SCancelFile $3 }
  | 'CANCEL' Groups { AbsKarel.SCancelGroup $2 }
  | Ident '(' ListExpression ')' { AbsKarel.SCallparamExp $1 $3 }
  | 'FOR' Ident '=' Integer 'TO' Integer 'DO' ListStm 'ENDFOR' { AbsKarel.SForTo $2 $4 $6 $8 }
  | 'FOR' Ident '=' Integer 'DOWNTO' Integer 'DO' ListStm 'ENDFOR' { AbsKarel.SForDownTo $2 $4 $6 $8 }
  | 'GOTO' Ident { AbsKarel.SGoTo $2 }
  | 'GO' 'TO' Ident { AbsKarel.SGo_To $3 }
  | 'HOLD' { AbsKarel.SHold }
  | 'HOLD' Groups { AbsKarel.SHoleGroup $2 }
  | 'IF' Expression 'THEN' ListStm 'ENDIF' { AbsKarel.SIfThen $2 $4 }
  | 'IF' Expression 'THEN' ListStm 'ELSE' ListStm 'EDNIF' { AbsKarel.SIfThenElse $2 $4 $6 }
  | 'PAUSE' { AbsKarel.SPause }
  | 'PAUSE' 'PROGRAM' '[' ListArrayIndexing ']' { AbsKarel.SPauseProgram $4 }
  | 'PULSE' PulseOut '[' ListArrayIndexing ']' 'FOR' Expression Nwait { AbsKarel.SPulse $2 $4 $7 $8 }
  | 'OPEN' 'FILE' Ident '(' Expression ',' Expression ')' { AbsKarel.SOpenFile $3 $5 $7 }
  | 'READ' Ident '(' ListReadItem ')' { AbsKarel.SReadIdent $2 $4 }
  | 'READ' '(' ListReadItem ')' { AbsKarel.SRead $3 }
  | 'RETURN' { AbsKarel.SReturn }
  | 'RETURN' '(' Expression ')' { AbsKarel.SReturnExp $3 }
  | 'USING' ListVarAccess 'DO' ListStm 'ENDUSING' { AbsKarel.SUsing $2 $4 }
  | 'UNHOLD' { AbsKarel.SUnHold }
  | 'UNHOLD' Groups { AbsKarel.SUnHoldExt $2 }
  | 'STOP' { AbsKarel.SStop }
  | 'STOP' Groups { AbsKarel.SStopExt $2 }
  | 'SELECT' Expression 'OF' ListCaseStm 'ENDSELECT' { AbsKarel.SSelect $2 $4 }
  | 'SELECT' Expression 'OF' ListCaseStm 'ELSE' ListStm 'ENDSELECT' { AbsKarel.SSelectElse $2 $4 $6 }
  | 'REPEAT' ListStm 'UNTIL' Expression { AbsKarel.SRepeat $2 $4 }
  | 'RESUM' { AbsKarel.SResum }
  | 'RESUM' Groups { AbsKarel.SResumGroup $2 }
  | 'WAIT' 'FOR' WaitSelect { AbsKarel.SWait $3 }
  | 'WHILE' Expression 'DO' ListStm 'ENDWHILE' { AbsKarel.SWhile $2 $4 }
  | 'WRITE' Ident '(' ListWriteItem ')' { AbsKarel.SWrite $2 $4 }
  | 'CONDITION' '[' ListArrayIndexing ']' ':' ConditionWhenStm 'ENDCONDITION' { AbsKarel.SCondition $3 $6 }
  | 'CONDITION' '[' ListArrayIndexing ']' ':' 'WITH' ListConditionWithStm ConditionWhenStm 'ENDCONDITION' { AbsKarel.SConditionWith $3 $7 $8 }
  | 'MOVE' 'TO' Expression { AbsKarel.SMove $3 }
  | 'MOVE' 'LINEAR' 'TO' Expression { AbsKarel.SMoveLinear $4 }
  | 'MOVE' 'JOINT' 'TO' Expression { AbsKarel.SMoveJoint $4 }
  | 'MOVE' 'CIRCULAR' 'TO' Expression 'VIA' Expression { AbsKarel.SMoveCircular $4 $6 }
  | 'GET_VAR' '(' Expression ',' Ident ',' Expression ',' Ident ')' { AbsKarel.SGetVar $3 $5 $7 $9 }
  | 'SET_VAR' '(' Expression ',' Ident ',' Expression ',' Expression ',' Ident ')' { AbsKarel.SSetVar $3 $5 $7 $9 $11 }
  | 'GET_PORT' '(' Expression ',' Ident ')' { AbsKarel.SGetPort $3 $5 }
  | 'SET_PORT' '(' Expression ',' Expression ',' Ident ')' { AbsKarel.SSetPort $3 $5 $7 }
  | 'GET_REG' '(' Expression ',' Ident ',' Ident ')' { AbsKarel.SGetReg $3 $5 $7 }
  | 'SET_REG' '(' Expression ',' Expression ',' Ident ')' { AbsKarel.SSetReg $3 $5 $7 }
  | 'GET_TPE_PRM' '(' Ident ',' Ident ',' Ident ')' { AbsKarel.SGetTPE $3 $5 $7 }
  | 'SET_TPE_PRM' '(' Ident ',' Ident ',' Ident ')' { AbsKarel.SSetTPE $3 $5 $7 }
  | 'CLR_TPE_STAT' { AbsKarel.SClearTPE }
  | 'GET_JPOS_REG' '(' Expression ',' Ident ',' Ident ')' { AbsKarel.SGetJPos $3 $5 $7 }
  | 'SET_JPOS_REG' '(' Expression ',' Ident ',' Ident ')' { AbsKarel.SSetJPos $3 $5 $7 }
  | 'GET_POS_REG' '(' Expression ',' Ident ',' Ident ')' { AbsKarel.SGetPosReg $3 $5 $7 }
  | 'SET_POS_REG' '(' Expression ',' Ident ',' Ident ')' { AbsKarel.SSetPosReg $3 $5 $7 }
  | 'GET_POS_TPE' '(' Ident ',' Ident ',' Ident ')' { AbsKarel.SGetPosTPE $3 $5 $7 }
  | 'SET_POS_TPE' '(' Ident ',' Ident ',' Ident ')' { AbsKarel.SSetPosTPE $3 $5 $7 }
  | 'MSG_OK' '(' Expression ',' Ident ')' { AbsKarel.SMsg $3 $5 }
  | 'ACTIVATE_SCREEN' '(' Ident ')' { AbsKarel.SActScreen $3 }
  | 'DEACTIVATE_SCREEN' '(' Ident ')' { AbsKarel.SDeactScreen $3 }

ConditionWhenStm :: { AbsKarel.ConditionWhenStm }
ConditionWhenStm
  : 'WHEN' GlobalConditionList 'DO' ListConditionHandlerAction { AbsKarel.CWSTMWhen $2 $4 }

ConditionWithStm :: { AbsKarel.ConditionWithStm }
ConditionWithStm
  : Ident '[' ListArrayIndexing ']' Ident '=' Expression { AbsKarel.CWSTMWith $1 $3 $5 $7 }

ListConditionWithStm :: { [AbsKarel.ConditionWithStm] }
ListConditionWithStm
  : {- empty -} { [] }
  | ConditionWithStm ',' ListConditionWithStm { (:) $1 $3 }

GlobalConditionList :: { AbsKarel.GlobalConditionList }
GlobalConditionList
  : GlobalCondition 'AND' GlobalCondition { AbsKarel.GCLAnd $1 $3 }
  | GlobalCondition 'OR' GlobalCondition { AbsKarel.GCLOr $1 $3 }

Groups :: { AbsKarel.Groups }
Groups
  : 'GROUP' '[' ListArrayIndexing ']' { AbsKarel.GroupBase $3 }

ListStm :: { [AbsKarel.Stm] }
ListStm : {- empty -} { [] } | Stm ListStm { (:) $1 $2 }

WaitSelect :: { AbsKarel.WaitSelect }
WaitSelect
  : GlobalCondition { AbsKarel.WaitSelectGC $1 }
  | GlobalCondition 'AND' GlobalCondition { AbsKarel.WaitSelectAND $1 $3 }
  | GlobalCondition 'OR' GlobalCondition { AbsKarel.WaitSelectOR $1 $3 }

CaseStm :: { AbsKarel.CaseStm }
CaseStm
  : 'CASE' '(' ListArrayIndexing ')' ':' ListStm { AbsKarel.SCase $3 $6 }

ListCaseStm :: { [AbsKarel.CaseStm] }
ListCaseStm
  : {- empty -} { [] } | CaseStm ';' ListCaseStm { (:) $1 $3 }

VarAccess :: { AbsKarel.VarAccess }
VarAccess
  : Ident { AbsKarel.SVarAccess $1 }
  | VarAccess '.' Ident { AbsKarel.SVarAccessIdent $1 $3 }
  | VarAccess '[' ListArrayIndexing ']' { AbsKarel.SVarAccessArray $1 $3 }
  | VarAccess '[' Expression '..' Expression ']' { AbsKarel.SVarAccessPath $1 $3 $5 }

ListVarAccess :: { [AbsKarel.VarAccess] }
ListVarAccess
  : {- empty -} { [] } | VarAccess ',' ListVarAccess { (:) $1 $3 }

ReadItem :: { AbsKarel.ReadItem }
ReadItem : CR FormatSpec { AbsKarel.SReadItem $1 $2 }

ListReadItem :: { [AbsKarel.ReadItem] }
ListReadItem
  : {- empty -} { [] } | ReadItem ',' ListReadItem { (:) $1 $3 }

WriteItem :: { AbsKarel.WriteItem }
WriteItem
  : CR FormatSpec { AbsKarel.SWriteItem $1 $2 }
  | Expression FormatSpec { AbsKarel.SWriteItemExp $1 $2 }

ListWriteItem :: { [AbsKarel.WriteItem] }
ListWriteItem
  : {- empty -} { [] } | WriteItem ',' ListWriteItem { (:) $1 $3 }

FormatSpec :: { AbsKarel.FormatSpec }
FormatSpec
  : '::' Expression { AbsKarel.FormatSpec1 $2 }
  | '::' Expression '::' Expression { AbsKarel.FormatSpec2 $2 $4 }
  | Empty { AbsKarel.FormatSpecEmpty $1 }

CR :: { AbsKarel.CR }
CR : 'CR' { AbsKarel.RIDefault } | Ident { AbsKarel.RICar $1 }

PulseOut :: { AbsKarel.PulseOut }
PulseOut
  : 'DOUT' { AbsKarel.SSPulseOut } | 'RDO' { AbsKarel.SSPulseRDO }

Nwait :: { AbsKarel.Nwait }
Nwait
  : 'NOWAIT' { AbsKarel.SSWait } | Empty { AbsKarel.SSWaitEmapty $1 }

Expression :: { AbsKarel.Expression }
Expression
  : '(' Expression ')' { AbsKarel.EBrack $2 }
  | Expression '=' Expression { AbsKarel.EEqual $1 $3 }
  | Expression '<>' Expression { AbsKarel.ENEqual $1 $3 }
  | Expression '<' Expression { AbsKarel.ELess $1 $3 }
  | Expression '<=' Expression { AbsKarel.ELeq $1 $3 }
  | Expression '>' Expression { AbsKarel.Egret $1 $3 }
  | Expression '>=' Expression { AbsKarel.Egeq $1 $3 }
  | Expression '>=<' Expression { AbsKarel.Esp $1 $3 }
  | Expression '+' Expression { AbsKarel.EAdd $1 $3 }
  | Expression '-' Expression { AbsKarel.ESub $1 $3 }
  | Expression 'OR' Expression { AbsKarel.EOR $1 $3 }
  | '+' Expression { AbsKarel.EPlus $2 }
  | '-' Expression { AbsKarel.EMinus $2 }
  | Expression '*' Expression { AbsKarel.EMul $1 $3 }
  | Expression '/' Expression { AbsKarel.EAdiv $1 $3 }
  | Expression 'AND' Expression { AbsKarel.EAnd $1 $3 }
  | Expression 'MOD' Expression { AbsKarel.EMOD $1 $3 }
  | Expression 'DIV' Expression { AbsKarel.EDiv $1 $3 }
  | Expression 'NOT' Expression { AbsKarel.ENot $1 $3 }
  | Expression ':' Expression { AbsKarel.EDot $1 $3 }
  | Expression '@' Expression { AbsKarel.EAt $1 $3 }
  | Expression '#' Expression { AbsKarel.EHash $1 $3 }
  | Ident { AbsKarel.EIdent $1 }
  | Text { AbsKarel.EQString $1 }
  | Double { AbsKarel.EDouble $1 }
  | Integer { AbsKarel.EInt $1 }
  | 'ABS' '(' Expression ')' { AbsKarel.EABS $3 }
  | 'ACOS' '(' Expression ')' { AbsKarel.EACOS $3 }
  | 'ASIN' '(' Expression ')' { AbsKarel.EASIN $3 }
  | 'ATAN2' '(' Expression ',' Expression ')' { AbsKarel.EATAN2 $3 $5 }
  | 'COS' '(' Expression ')' { AbsKarel.ECOS $3 }
  | 'SIN' '(' Expression ')' { AbsKarel.ESin $3 }
  | 'TAN' '(' Expression ')' { AbsKarel.ETan $3 }
  | 'SQRT' '(' Expression ')' { AbsKarel.ESqrt $3 }
  | 'LN' '(' Expression ')' { AbsKarel.ELn $3 }
  | 'EXP' '(' Expression ')' { AbsKarel.EExp $3 }
  | 'TRUNC' '(' Expression ')' { AbsKarel.ETrunc $3 }
  | 'ROUND' '(' Expression ')' { AbsKarel.ERound $3 }
  | 'STRLEN' '(' Expression ')' { AbsKarel.EStrlen $3 }
  | 'SUBSTR' '(' Expression ',' Expression ',' Expression ')' { AbsKarel.ESubstr $3 $5 $7 }
  | 'CHR' '(' Expression ')' { AbsKarel.EChr $3 }
  | 'ORD' '(' Expression ')' { AbsKarel.EOrd $3 }
  | 'UNINIT' '(' Expression ')' { AbsKarel.EUninitd $3 }
  | 'CURPOS' '(' Expression ',' Expression ')' { AbsKarel.ECurPos $3 $5 }
  | 'CURJPOS' '(' Expression ',' Expression ')' { AbsKarel.ECurJPos $3 $5 }
  | 'POS_TO_JPOS' '(' Expression ',' Expression ')' { AbsKarel.EPosToJ $3 $5 }
  | 'JPOS_TO_POS' '(' Expression ',' Expression ')' { AbsKarel.EJToPos $3 $5 }

ListExpression :: { [AbsKarel.Expression] }
ListExpression
  : Expression { (:[]) $1 }
  | Expression ',' ListExpression { (:) $1 $3 }

UserType :: { AbsKarel.UserType }
UserType
  : Ident '=' DataTypes { AbsKarel.UserTypeDT $1 $3 }
  | 'STRUCTURE' Ident OptLineEnd ListVarDecl 'ENDSTRUCTURE' { AbsKarel.UserTypeStruct $2 $3 $4 }

Empty :: { AbsKarel.Empty }
Empty : {- empty -} { AbsKarel.EmpyType }

MemTypes :: { AbsKarel.MemTypes }
MemTypes
  : 'CMOS' { AbsKarel.MemTypeDMOS }
  | 'DRAM' { AbsKarel.MemTypeDRAM }
  | Empty { AbsKarel.MemTypeEmpty $1 }

ReturnDataTypes :: { AbsKarel.ReturnDataTypes }
ReturnDataTypes
  : Ident { AbsKarel.RDTIdent $1 }
  | Char { AbsKarel.RDTChar $1 }
  | 'INTEGER' { AbsKarel.RDTInt }
  | 'REAL' { AbsKarel.RDTReal }
  | 'BOOLEAN' { AbsKarel.RDTBool }
  | 'VECTOR' { AbsKarel.RDTVector }
  | 'CONFIG' { AbsKarel.RDTConfig }
  | 'COMMON_ASSOC' { AbsKarel.RDTCommon }
  | PositionDataTypes 'IN' 'GROUP' '[' Integer ']' { AbsKarel.RDTPos $1 $5 }
  | 'STRING' { AbsKarel.RDTString }
  | 'ARRAY' '[' ListReturnArrayIndex ']' 'OF' StructuredArrayType { AbsKarel.RDTArray $3 $6 }

ParameterDataTypes :: { AbsKarel.ParameterDataTypes }
ParameterDataTypes
  : Ident { AbsKarel.PDTIdent $1 }
  | Char { AbsKarel.PDTChar $1 }
  | 'INTEGER' { AbsKarel.PDTInt }
  | 'REAL' { AbsKarel.PDTReal }
  | 'BOOLEAN' { AbsKarel.PDTBool }
  | 'VECTOR' { AbsKarel.PDTVector }
  | 'VIS_PROCESS' { AbsKarel.PDTVis }
  | 'MODEL' { AbsKarel.PDTModel }
  | 'CAM_SETUP' { AbsKarel.PDTCam }
  | 'FILE' { AbsKarel.PDTFile }
  | 'CONFIG' { AbsKarel.PDTConf }
  | 'PATH' PathDataType { AbsKarel.PDTPath $2 }
  | 'COMMON_ASSOC' { AbsKarel.PDTCommon }
  | PositionDataTypes 'IN' 'GROUP' '[' Integer ']' { AbsKarel.PDTPos $1 $5 }
  | 'STRING' { AbsKarel.PDTString }
  | 'ARRAY' '[' DataTypes ']' 'OF' StructuredArrayType { AbsKarel.PDTArray $3 $6 }

DataTypes :: { AbsKarel.DataTypes }
DataTypes
  : 'STRING' '[' Integer ']' { AbsKarel.DTString $3 }
  | 'ARRAY' '[' ListArrayIndexing ']' 'OF' StructuredArrayType { AbsKarel.DTArray $3 $6 }
  | StructuredArrayType { AbsKarel.DTStruct $1 }
  | ParameterDataTypes { AbsKarel.DTParam $1 }

StructuredArrayType :: { AbsKarel.StructuredArrayType }
StructuredArrayType
  : 'SHORT' { AbsKarel.SATShort } | 'BYTE' { AbsKarel.SATByte }

PathDataType :: { AbsKarel.PathDataType }
PathDataType
  : 'PATH' 'HEADER' '=' Ident { AbsKarel.PathDTHeader $4 }
  | 'NODE' 'DATA' '=' Ident { AbsKarel.PathDTNode $4 }
  | Empty { AbsKarel.PathDtEmpty $1 }
  | 'PATH' 'HEADER' '=' Ident ',' 'NODE' 'DATA' '=' Ident { AbsKarel.PathDtHeaderExt $4 $9 }

PositionDataTypes :: { AbsKarel.PositionDataTypes }
PositionDataTypes
  : 'POSITION' { AbsKarel.PDTyPos }
  | 'XYZWPR' { AbsKarel.PDTyXYZ }
  | 'JOINTPOS' { AbsKarel.PDTyJPos }
  | 'JOINTPOS1' { AbsKarel.PDTyJPos1 }
  | 'JOINTPOS2' { AbsKarel.PDTyJPos2 }
  | 'JOINTPOS3' { AbsKarel.PDTyJPos3 }
  | 'JOINTPOS4' { AbsKarel.PDTyJPos4 }
  | 'JOINTPOS5' { AbsKarel.PDTyJPos5 }
  | 'JOINTPOS6' { AbsKarel.PDTyJPos6 }
  | 'JOINTPOS7' { AbsKarel.PDTyJPos7 }
  | 'JOINTPOS8' { AbsKarel.PDTyJPos8 }
  | 'JOINTPOS9' { AbsKarel.PDTyJPos9 }
  | 'XYZWPREXT' { AbsKarel.PDTyXYZEXT }
  | 'GROUP_ASSOC' { AbsKarel.PDTyGAssoc }

BoolDataTypes :: { AbsKarel.BoolDataTypes }
BoolDataTypes
  : 'TRUE' { AbsKarel.BDTTrue } | 'FALSE' { AbsKarel.BDTFalse }

ArrayIndexing :: { AbsKarel.ArrayIndexing }
ArrayIndexing : Integer { AbsKarel.IntArrayIndex $1 }

ListArrayIndexing :: { [AbsKarel.ArrayIndexing] }
ListArrayIndexing
  : {- empty -} { [] }
  | ArrayIndexing { (:[]) $1 }
  | ArrayIndexing ',' ListArrayIndexing { (:) $1 $3 }

ReturnArrayIndex :: { AbsKarel.ReturnArrayIndex }
ReturnArrayIndex
  : Integer { AbsKarel.ReturnArrayInteger $1 }
  | '*' { AbsKarel.ReturnArrayAster }

ListReturnArrayIndex :: { [AbsKarel.ReturnArrayIndex] }
ListReturnArrayIndex
  : {- empty -} { [] }
  | ReturnArrayIndex { (:[]) $1 }
  | ReturnArrayIndex ',' ListReturnArrayIndex { (:) $1 $3 }

Sign :: { AbsKarel.Sign }
Sign
  : '+' { AbsKarel.SignPlus }
  | '-' { AbsKarel.SignMinus }
  | Empty { AbsKarel.SignEmpty $1 }

Literal :: { AbsKarel.Literal }
Literal
  : Integer { AbsKarel.LiteralInteger $1 }
  | Double { AbsKarel.LiteralDouble $1 }
  | Text { AbsKarel.LiteralQuoted $1 }

Text :: { AbsKarel.Text }
Text
  : String { AbsKarel.TextString $1 }
  | QuotedString { AbsKarel.TextQuotedString $1 }

Constant :: { AbsKarel.Constant }
Constant
  : Literal { AbsKarel.ConstLiteral $1 }
  | Ident { AbsKarel.ConstIdent $1 }

OptLineEnd :: { AbsKarel.OptLineEnd }
OptLineEnd
  : LineEnd { AbsKarel.OptLineEndLineEnd $1 }
  | Empty { AbsKarel.OptLineEndEmpty $1 }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

}

