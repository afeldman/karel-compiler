#!/usr/bin/env python3
"""
Configure script for Karel Ninja build system
Generates build.ninja from build.ninja.template with custom settings

Usage:
    ./configure.py [options]
    
Options:
    --karelc PATH         Path to karelc compiler (default: karelc)
    --aku-path PATH       Path to AKU library (default: ../aku)
    --build-dir PATH      Build output directory (default: build)
    --opt-level LEVEL     Optimization level 0-3 (default: 2)
    --sources PATTERN     Source file pattern (default: test/*.kl)
    --debug               Enable debug mode (opt-level=0, keep preprocessor output)
    --release             Release mode (opt-level=3, strip symbols)
    --help                Show this help
"""

import argparse
import glob
import os
import sys
from pathlib import Path

def find_sources(pattern):
    """Find all Karel source files matching pattern"""
    sources = glob.glob(pattern)
    return [Path(s) for s in sources]

def generate_ninja_build(args):
    """Generate build.ninja file from template and arguments"""
    
    sources = find_sources(args.sources)
    if not sources:
        print(f"Warning: No source files found matching '{args.sources}'", file=sys.stderr)
    
    # Start building ninja file
    lines = [
        "# Ninja build file for Karel project",
        "# Auto-generated by configure.py - DO NOT EDIT",
        "# Run './configure.py' to regenerate",
        "",
        "# Configuration",
        f"karelc = {args.karelc}",
        f"aku_path = {args.aku_path}",
        f"build_dir = {args.build_dir}",
        f"opt_level = {args.opt_level}",
        "",
        "# Compiler flags",
        f"cflags = -O$opt_level",
        f"karelflags = --aku-path $aku_path",
        "",
    ]
    
    # Add debug flags
    if args.debug:
        lines.extend([
            "# Debug mode",
            "cflags = $cflags -g -DDEBUG",
            "karelflags = $karelflags",
            "",
        ])
    
    # Add release flags
    if args.release:
        lines.extend([
            "# Release mode",
            "cflags = $cflags -s",
            "",
        ])
    
    # Rules
    lines.extend([
        "# Build rules",
        "rule karel_compile",
        "  command = $karelc $in $karelflags -o $out",
        "  description = Compiling Karel: $in → $out",
        "",
        "rule karel_llvm",
        "  command = $karelc $in $karelflags -emit-llvm -o $out",
        "  description = Generating LLVM IR: $in → $out",
        "",
        "rule karel_asm",
        "  command = $karelc $in $karelflags -S -o $out",
        "  description = Generating Assembly: $in → $out",
        "",
        "rule karel_preprocess",
        "  command = $karelc $in $karelflags --precompile > $out",
        "  description = Preprocessing: $in → $out",
        "",
        "rule link",
        "  command = clang $in -o $out $cflags",
        "  description = Linking: $out",
        "",
        "rule mkdir",
        "  command = mkdir -p $out",
        "  description = Creating directory: $out",
        "",
        "rule clean_rule",
        "  command = rm -rf $build_dir",
        "  description = Cleaning build directory",
        "",
        "# Create build directory",
        f"build {args.build_dir}: mkdir",
        "",
        "# Build targets",
    ])
    
    # Generate build targets for each source file
    obj_files = []
    ll_files = []
    asm_files = []
    pp_files = []
    exe_files = []
    
    for source in sources:
        stem = source.stem
        
        # Object file
        obj = f"$build_dir/{stem}.o"
        obj_files.append(obj)
        lines.append(f"build {obj}: karel_compile {source} | $build_dir")
        
        # LLVM IR
        ll = f"$build_dir/{stem}.ll"
        ll_files.append(ll)
        lines.append(f"build {ll}: karel_llvm {source} | $build_dir")
        
        # Assembly
        asm = f"$build_dir/{stem}.s"
        asm_files.append(asm)
        lines.append(f"build {asm}: karel_asm {source} | $build_dir")
        
        # Preprocessor output
        pp = f"$build_dir/{stem}.pp.kl"
        pp_files.append(pp)
        lines.append(f"build {pp}: karel_preprocess {source} | $build_dir")
        
        # Executable (link object file)
        exe = f"$build_dir/{stem}"
        exe_files.append(exe)
        lines.append(f"build {exe}: link {obj}")
        
        lines.append("")
    
    # Phony targets
    lines.extend([
        "# Phony targets",
        f"build all: phony {' '.join(obj_files)}",
        f"build llvm: phony {' '.join(ll_files)}",
        f"build asm: phony {' '.join(asm_files)}",
        f"build preprocess: phony {' '.join(pp_files)}",
        f"build executables: phony {' '.join(exe_files)}",
        "build clean: clean_rule",
        "",
        "default all",
    ])
    
    return '\n'.join(lines)

def main():
    parser = argparse.ArgumentParser(
        description='Configure Karel Ninja build system',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=__doc__
    )
    
    parser.add_argument('--karelc', default='karelc',
                        help='Path to karelc compiler (default: karelc)')
    parser.add_argument('--aku-path', default='../aku',
                        help='Path to AKU library (default: ../aku)')
    parser.add_argument('--build-dir', default='build',
                        help='Build output directory (default: build)')
    parser.add_argument('--opt-level', type=int, default=2, choices=[0, 1, 2, 3],
                        help='Optimization level 0-3 (default: 2)')
    parser.add_argument('--sources', default='test/*.kl',
                        help='Source file pattern (default: test/*.kl)')
    parser.add_argument('--debug', action='store_true',
                        help='Enable debug mode (opt-level=0)')
    parser.add_argument('--release', action='store_true',
                        help='Release mode (opt-level=3, strip)')
    parser.add_argument('--output', default='build.ninja',
                        help='Output file (default: build.ninja)')
    
    args = parser.parse_args()
    
    # Override opt-level for debug/release
    if args.debug:
        args.opt_level = 0
    if args.release:
        args.opt_level = 3
    
    # Generate ninja file
    ninja_content = generate_ninja_build(args)
    
    # Write to file
    with open(args.output, 'w') as f:
        f.write(ninja_content)
    
    print(f"Generated {args.output}")
    print(f"Configuration:")
    print(f"  Compiler: {args.karelc}")
    print(f"  AKU path: {args.aku_path}")
    print(f"  Build dir: {args.build_dir}")
    print(f"  Optimization: -O{args.opt_level}")
    print(f"  Sources: {args.sources}")
    
    sources = find_sources(args.sources)
    print(f"  Found {len(sources)} source file(s)")
    
    print("\nRun 'ninja' to build")
    print("Run 'ninja -t targets' to see all targets")
    print("Run 'ninja clean' to clean build directory")

if __name__ == '__main__':
    main()
